{"version":3,"sources":["webpack:///./node_modules/_ol@5.3.1@ol/format/xsd.js","webpack:///./src/views/oneMap.vue?3639","webpack:///./node_modules/_ol@5.3.1@ol/format/Feature.js","webpack:///./node_modules/_ol@5.3.1@ol/format/XMLFeature.js","webpack:///./node_modules/_ol@5.3.1@ol/format/GPX.js","webpack:///./node_modules/_ol-ext@3.1.2@ol-ext/style/Shadow.js","webpack:///./node_modules/_ol-ext@3.1.2@ol-ext/featureanimation/FeatureAnimation.js","webpack:///./node_modules/_ol-ext@3.1.2@ol-ext/featureanimation/Path.js","webpack:///src/views/oneMap.vue","webpack:///./src/views/oneMap.vue?9d69","webpack:///./src/views/oneMap.vue","webpack:///./node_modules/_ol@5.3.1@ol/geom/flat/interpolate.js","webpack:///./node_modules/_ol@5.3.1@ol/geom/LineString.js","webpack:///./node_modules/_ol@5.3.1@ol/geom/MultiLineString.js","webpack:///./node_modules/_ol@5.3.1@ol/xml.js"],"names":["__webpack_require__","d","__webpack_exports__","readDateTime","readDecimal","readNonNegativeInteger","readString","writeDateTimeTextNode","writeDecimalTextNode","writeNonNegativeIntegerTextNode","writeStringTextNode","_xml_js__WEBPACK_IMPORTED_MODULE_0__","_string_js__WEBPACK_IMPORTED_MODULE_1__","node","s","Object","dateTime","Date","parse","isNaN","undefined","readDecimalString","string","m","exec","parseFloat","readNonNegativeIntegerString","parseInt","trim","date","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","appendChild","createTextNode","decimal","toPrecision","nonNegativeInteger","toString","render","_vm","this","_h","$createElement","_c","_self","style","attrs","id","staticRenderFns","Feature_FeatureFormat","dataProjection","defaultFeatureProjection","prototype","getReadOptions","source","opt_options","options","readProjection","featureProjection","adaptOptions","obj","getLastExtent","getType","_ol_5_3_1_ol_util","readFeature","readFeatures","readGeometry","writeFeature","feature","writeFeatures","features","writeGeometry","geometry","format_Feature","transformWithOptions","write","transformed","proj","Array","isArray","clone","transform","decimals","power","Math","pow","coordinates","i","ii","length","round","applyTransform","XMLFeature_XMLFeature","FeatureFormat","XMLFeature","call","xmlSerializer_","XMLSerializer","__proto__","create","constructor","FormatType","XML","doc","xml","readFeatureFromDocument","readFeatureFromNode","readFeaturesFromDocument","readFeaturesFromNode","n","nextSibling","nodeType","Node","ELEMENT_NODE","array","readGeometryFromDocument","readGeometryFromNode","readProjectionFromDocument","readProjectionFromNode","writeFeatureNode","serializeToString","writeFeaturesNode","writeGeometryNode","format_XMLFeature","NAMESPACE_URIS","SCHEMA_LOCATION","FEATURE_READER","rte","readRte","trk","readTrk","wpt","readWpt","GPX_PARSERS","LINK_PARSERS","text","xsd","type","GPX_SERIALIZERS","writeRte","writeTrk","writeWpt","GPX_GPX","GPX","readExtensions_","readExtensions","handleReadExtensions_","extensionsNode","get","set","namespaceURI","featureReader","localName","gpx","xmlnsUri","setAttributeNS","setAttribute","GPX_NODE_FACTORY","RTE_PARSERS","name","cmt","desc","src","link","parseLink","number","extensions","parseExtensions","rtept","parseRtePt","RTEPT_PARSERS","ele","time","TRK_PARSERS","trkseg","parseTrkSeg","TRKSEG_PARSERS","trkpt","parseTrkPt","TRKPT_PARSERS","WPT_PARSERS","magvar","geoidheight","sym","fix","sat","hdop","vdop","pdop","ageofdgpsdata","dgpsid","LINK_SEQUENCE","LINK_SERIALIZERS","RTE_SEQUENCE","RTE_SERIALIZERS","writeLink","writeWptType","RTEPT_TYPE_SEQUENCE","TRK_SEQUENCE","TRK_SERIALIZERS","writeTrkSeg","TRKSEG_NODE_FACTORY","TRKSEG_SERIALIZERS","WPT_TYPE_SEQUENCE","WPT_TYPE_SERIALIZERS","GEOMETRY_TYPE_TO_NODENAME","Point","LineString","MultiLineString","value","objectStack","opt_nodeName","getGeometry","nodeName","parentNode","appendCoordinate","flatCoordinates","layoutOptions","values","push","getAttribute","hasZ","hasM","applyLayoutOptions","ends","layout","GeometryLayout","XY","stride","XYZM","XYZ","XYM","i$1","ii$1","href","rteValues","trkValues","Feature","setProperties","context","properties","coordinate","String","geometryLayout","orderedKeys","getProperties","GeometryType","LINE_STRING","lineString","getLayout","getCoordinates","MULTI_LINE_STRING","multiLineString","getLineStrings","POINT","point","format_GPX","ol_style_Shadow","fill","Fill","color","RegularShape","radius","fill_","radius_","blur_","blur","offset_","offsetX","offsetY","renderShadow_","setScale","getScale","setOpacity","getOpacity","canvas","getImage","width","height","getContext","beginPath","clearRect","scale","arc","PI","fillStyle","shadowColor","getColor","shadowBlur","shadowOffsetX","shadowOffsetY","closePath","a","getAnchor","getChecksum","strokeChecksum","stroke_","fillChecksum","recalculate","checksums_","form_","glyphs_","checksum","Shadow","ol_featureAnimation","duration_","duration","fade_","fade","repeat_","Number","repeat","easing","_ol_5_3_1_ol_easing","revers","easing_","t","hiddenStyle","_ol_5_3_1_ol_Object","drawGeom_","e","geom","shadow","globalAlpha","elapsed","sc","imgs","Map","getFeaturesAtPixel","frameState","pixelRatio","vectorContext","setStyle","getZIndex","drawGeometry","animate","animateFeature","layer_Vector","fanim","listenerKey","self","getStyle","flashStyle","getStyleFunction","event","start","extent","typeGeom","bbox","getExtent","coord","splice","nb","step","dispatchEvent","stop","Observable","hasOwnProperty","on","bind","renderSync","changed","isPlaying","FeatureAnimation","ol_featureAnimation_Path","speed_","speed","path_","path","rotate","rotate_","getLineString","getLength","dist_","p0","p","dx","dy","dl","dmax","sqrt","angle","atan2","k","setRotation","setCoordinates","Path","oneMapvue_type_script_lang_js_","data","map","view","layers","MapStyle","window","innerHeight","methods","preDefine","View","zoom","center","projection","Tile","OSM","opacity","createMap","controls","util","attribution","target","console","log","getView","getZoom","addGPXData","Style","image","stroke","Stroke","zIndex","radius2","points","Vector","url","format","vector","addLayer","once","getState","getFeatures","f","anim","setTimeout","mounted","views_oneMapvue_type_script_lang_js_","component","componentNormalizer","interpolatePoint","lineStringCoordinateAtM","lineStringsCoordinateAtM","_array_js__WEBPACK_IMPORTED_MODULE_0__","_math_js__WEBPACK_IMPORTED_MODULE_1__","offset","end","fraction","opt_dest","pointX","NaN","pointY","x1","y1","cumulativeLengths","x2","y2","index","o","extrapolate","slice","lo","hi","mid","m0","m1","interpolate","_extent_js__WEBPACK_IMPORTED_MODULE_1__","_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_2__","_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__","_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_4__","_flat_closest_js__WEBPACK_IMPORTED_MODULE_5__","_flat_deflate_js__WEBPACK_IMPORTED_MODULE_6__","_flat_inflate_js__WEBPACK_IMPORTED_MODULE_7__","_flat_interpolate_js__WEBPACK_IMPORTED_MODULE_8__","_flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_9__","_flat_length_js__WEBPACK_IMPORTED_MODULE_10__","_flat_segments_js__WEBPACK_IMPORTED_MODULE_11__","_flat_simplify_js__WEBPACK_IMPORTED_MODULE_12__","SimpleGeometry","opt_layout","flatMidpoint_","flatMidpointRevision_","maxDelta_","maxDeltaRevision_","setFlatCoordinates","closestPointXY","x","y","closestPoint","minSquaredDistance","getRevision","forEachSegment","callback","getCoordinateAtM","opt_extrapolate","getCoordinateAt","getFlatMidpoint","getSimplifiedGeometryInternal","squaredTolerance","simplifiedFlatCoordinates","intersectsExtent","setLayout","_LineString_js__WEBPACK_IMPORTED_MODULE_4__","_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_5__","_flat_closest_js__WEBPACK_IMPORTED_MODULE_6__","_flat_deflate_js__WEBPACK_IMPORTED_MODULE_7__","_flat_inflate_js__WEBPACK_IMPORTED_MODULE_8__","_flat_interpolate_js__WEBPACK_IMPORTED_MODULE_9__","_flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_10__","_flat_simplify_js__WEBPACK_IMPORTED_MODULE_11__","opt_ends","ends_","lineStrings","getFlatCoordinates","appendLineString","opt_interpolate","getEnds","getFlatMidpoints","midpoints","midpoint","simplifiedEnds","DOCUMENT","XML_SCHEMA_INSTANCE_URI","createElementNS","getAllTextContent","isDocument","makeArrayPusher","makeObjectPropertyPusher","makeObjectPropertySetter","makeChildAppender","makeArraySerializer","makeSimpleNodeFactory","OBJECT_PROPERTY_NODE_FACTORY","makeSequence","makeStructureNS","parseNode","pushParseAndPop","pushSerializeAndPop","document","implementation","createDocument","qualifiedName","normalizeWhitespace","getAllTextContent_","join","accumulator","CDATA_SECTION_NODE","TEXT_NODE","nodeValue","replace","firstChild","object","DOMParser","parseFromString","valueReader","opt_this","opt_property","property","nodeWriter","parent","serializersNS","nodeFactory","serializers","serialize","opt_namespaceURI","fixedNodeName","sequence","namespaceURIs","structure","opt_structureNS","structureNS","parsersNS","firstElementChild","nextElementSibling","parsers","parser","pop","opt_keys"],"mappings":"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","file":"js/chunk-f91ba166.2162c273.js","sourcesContent":["/**\n * @module ol/format/xsd\n */\nimport {getAllTextContent, DOCUMENT} from '../xml.js';\nimport {padNumber} from '../string.js';\n\n\n/**\n * @param {Node} node Node.\n * @return {boolean|undefined} Boolean.\n */\nexport function readBoolean(node) {\n  var s = getAllTextContent(node, false);\n  return readBooleanString(s);\n}\n\n\n/**\n * @param {string} string String.\n * @return {boolean|undefined} Boolean.\n */\nexport function readBooleanString(string) {\n  var m = /^\\s*(true|1)|(false|0)\\s*$/.exec(string);\n  if (m) {\n    return m[1] !== undefined || false;\n  } else {\n    return undefined;\n  }\n}\n\n\n/**\n * @param {Node} node Node.\n * @return {number|undefined} DateTime in seconds.\n */\nexport function readDateTime(node) {\n  var s = getAllTextContent(node, false);\n  var dateTime = Date.parse(s);\n  return isNaN(dateTime) ? undefined : dateTime / 1000;\n}\n\n\n/**\n * @param {Node} node Node.\n * @return {number|undefined} Decimal.\n */\nexport function readDecimal(node) {\n  var s = getAllTextContent(node, false);\n  return readDecimalString(s);\n}\n\n\n/**\n * @param {string} string String.\n * @return {number|undefined} Decimal.\n */\nexport function readDecimalString(string) {\n  // FIXME check spec\n  var m = /^\\s*([+\\-]?\\d*\\.?\\d+(?:e[+\\-]?\\d+)?)\\s*$/i.exec(string);\n  if (m) {\n    return parseFloat(m[1]);\n  } else {\n    return undefined;\n  }\n}\n\n\n/**\n * @param {Node} node Node.\n * @return {number|undefined} Non negative integer.\n */\nexport function readNonNegativeInteger(node) {\n  var s = getAllTextContent(node, false);\n  return readNonNegativeIntegerString(s);\n}\n\n\n/**\n * @param {string} string String.\n * @return {number|undefined} Non negative integer.\n */\nexport function readNonNegativeIntegerString(string) {\n  var m = /^\\s*(\\d+)\\s*$/.exec(string);\n  if (m) {\n    return parseInt(m[1], 10);\n  } else {\n    return undefined;\n  }\n}\n\n\n/**\n * @param {Node} node Node.\n * @return {string|undefined} String.\n */\nexport function readString(node) {\n  return getAllTextContent(node, false).trim();\n}\n\n\n/**\n * @param {Node} node Node to append a TextNode with the boolean to.\n * @param {boolean} bool Boolean.\n */\nexport function writeBooleanTextNode(node, bool) {\n  writeStringTextNode(node, (bool) ? '1' : '0');\n}\n\n\n/**\n * @param {Node} node Node to append a CDATA Section with the string to.\n * @param {string} string String.\n */\nexport function writeCDATASection(node, string) {\n  node.appendChild(DOCUMENT.createCDATASection(string));\n}\n\n\n/**\n * @param {Node} node Node to append a TextNode with the dateTime to.\n * @param {number} dateTime DateTime in seconds.\n */\nexport function writeDateTimeTextNode(node, dateTime) {\n  var date = new Date(dateTime * 1000);\n  var string = date.getUTCFullYear() + '-' +\n      padNumber(date.getUTCMonth() + 1, 2) + '-' +\n      padNumber(date.getUTCDate(), 2) + 'T' +\n      padNumber(date.getUTCHours(), 2) + ':' +\n      padNumber(date.getUTCMinutes(), 2) + ':' +\n      padNumber(date.getUTCSeconds(), 2) + 'Z';\n  node.appendChild(DOCUMENT.createTextNode(string));\n}\n\n\n/**\n * @param {Node} node Node to append a TextNode with the decimal to.\n * @param {number} decimal Decimal.\n */\nexport function writeDecimalTextNode(node, decimal) {\n  var string = decimal.toPrecision();\n  node.appendChild(DOCUMENT.createTextNode(string));\n}\n\n\n/**\n * @param {Node} node Node to append a TextNode with the decimal to.\n * @param {number} nonNegativeInteger Non negative integer.\n */\nexport function writeNonNegativeIntegerTextNode(node, nonNegativeInteger) {\n  var string = nonNegativeInteger.toString();\n  node.appendChild(DOCUMENT.createTextNode(string));\n}\n\n\n/**\n * @param {Node} node Node to append a TextNode with the string to.\n * @param {string} string String.\n */\nexport function writeStringTextNode(node, string) {\n  node.appendChild(DOCUMENT.createTextNode(string));\n}\n\n//# sourceMappingURL=xsd.js.map","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_c('div',{style:(_vm.MapStyle),attrs:{\"id\":\"map\"}})])}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","/**\n * @module ol/format/Feature\n */\nimport {assign} from '../obj.js';\nimport {abstract} from '../util.js';\nimport {get as getProjection, equivalent as equivalentProjection, transformExtent} from '../proj.js';\n\n\n/**\n * @typedef {Object} ReadOptions\n * @property {import(\"../proj.js\").ProjectionLike} [dataProjection] Projection of the data we are reading.\n * If not provided, the projection will be derived from the data (where possible) or\n * the `dataProjection` of the format is assigned (where set). If the projection\n * can not be derived from the data and if no `dataProjection` is set for a format,\n * the features will not be reprojected.\n * @property {import(\"../extent.js\").Extent} [extent] Tile extent of the tile being read. This is only used and\n * required for {@link module:ol/format/MVT}.\n * @property {import(\"../proj.js\").ProjectionLike} [featureProjection] Projection of the feature geometries\n * created by the format reader. If not provided, features will be returned in the\n * `dataProjection`.\n */\n\n\n/**\n * @typedef {Object} WriteOptions\n * @property {import(\"../proj.js\").ProjectionLike} [dataProjection] Projection of the data we are writing.\n * If not provided, the `dataProjection` of the format is assigned (where set).\n * If no `dataProjection` is set for a format, the features will be returned\n * in the `featureProjection`.\n * @property {import(\"../proj.js\").ProjectionLike} [featureProjection] Projection of the feature geometries\n * that will be serialized by the format writer. If not provided, geometries are assumed\n * to be in the `dataProjection` if that is set; in other words, they are not transformed.\n * @property {boolean} [rightHanded] When writing geometries, follow the right-hand\n * rule for linear ring orientation.  This means that polygons will have counter-clockwise\n * exterior rings and clockwise interior rings.  By default, coordinates are serialized\n * as they are provided at construction.  If `true`, the right-hand rule will\n * be applied.  If `false`, the left-hand rule will be applied (clockwise for\n * exterior and counter-clockwise for interior rings).  Note that not all\n * formats support this.  The GeoJSON format does use this property when writing\n * geometries.\n * @property {number} [decimals] Maximum number of decimal places for coordinates.\n * Coordinates are stored internally as floats, but floating-point arithmetic can create\n * coordinates with a large number of decimal places, not generally wanted on output.\n * Set a number here to round coordinates. Can also be used to ensure that\n * coordinates read in can be written back out with the same number of decimals.\n * Default is no rounding.\n */\n\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for feature formats.\n * {FeatureFormat} subclasses provide the ability to decode and encode\n * {@link module:ol/Feature~Feature} objects from a variety of commonly used geospatial\n * file formats.  See the documentation for each format for more details.\n *\n * @abstract\n * @api\n */\nvar FeatureFormat = function FeatureFormat() {\n\n  /**\n   * @protected\n   * @type {import(\"../proj/Projection.js\").default}\n   */\n  this.dataProjection = null;\n\n  /**\n   * @protected\n   * @type {import(\"../proj/Projection.js\").default}\n   */\n  this.defaultFeatureProjection = null;\n\n};\n\n/**\n * Adds the data projection to the read options.\n * @param {Document|Node|Object|string} source Source.\n * @param {ReadOptions=} opt_options Options.\n * @return {ReadOptions|undefined} Options.\n * @protected\n */\nFeatureFormat.prototype.getReadOptions = function getReadOptions (source, opt_options) {\n  var options;\n  if (opt_options) {\n    options = {\n      dataProjection: opt_options.dataProjection ?\n        opt_options.dataProjection : this.readProjection(source),\n      featureProjection: opt_options.featureProjection\n    };\n  }\n  return this.adaptOptions(options);\n};\n\n/**\n * Sets the `dataProjection` on the options, if no `dataProjection`\n * is set.\n * @param {WriteOptions|ReadOptions|undefined} options\n *   Options.\n * @protected\n * @return {WriteOptions|ReadOptions|undefined}\n *   Updated options.\n */\nFeatureFormat.prototype.adaptOptions = function adaptOptions (options) {\n  return assign({\n    dataProjection: this.dataProjection,\n    featureProjection: this.defaultFeatureProjection\n  }, options);\n};\n\n/**\n * Get the extent from the source of the last {@link readFeatures} call.\n * @return {import(\"../extent.js\").Extent} Tile extent.\n */\nFeatureFormat.prototype.getLastExtent = function getLastExtent () {\n  return null;\n};\n\n/**\n * @abstract\n * @return {import(\"./FormatType.js\").default} Format.\n */\nFeatureFormat.prototype.getType = function getType () {\n  return abstract();\n};\n\n/**\n * Read a single feature from a source.\n *\n * @abstract\n * @param {Document|Node|Object|string} source Source.\n * @param {ReadOptions=} opt_options Read options.\n * @return {import(\"../Feature.js\").FeatureLike} Feature.\n */\nFeatureFormat.prototype.readFeature = function readFeature (source, opt_options) {\n  return abstract();\n};\n\n/**\n * Read all features from a source.\n *\n * @abstract\n * @param {Document|Node|ArrayBuffer|Object|string} source Source.\n * @param {ReadOptions=} opt_options Read options.\n * @return {Array<import(\"../Feature.js\").FeatureLike>} Features.\n */\nFeatureFormat.prototype.readFeatures = function readFeatures (source, opt_options) {\n  return abstract();\n};\n\n/**\n * Read a single geometry from a source.\n *\n * @abstract\n * @param {Document|Node|Object|string} source Source.\n * @param {ReadOptions=} opt_options Read options.\n * @return {import(\"../geom/Geometry.js\").default} Geometry.\n */\nFeatureFormat.prototype.readGeometry = function readGeometry (source, opt_options) {\n  return abstract();\n};\n\n/**\n * Read the projection from a source.\n *\n * @abstract\n * @param {Document|Node|Object|string} source Source.\n * @return {import(\"../proj/Projection.js\").default} Projection.\n */\nFeatureFormat.prototype.readProjection = function readProjection (source) {\n  return abstract();\n};\n\n/**\n * Encode a feature in this format.\n *\n * @abstract\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {WriteOptions=} opt_options Write options.\n * @return {string} Result.\n */\nFeatureFormat.prototype.writeFeature = function writeFeature (feature, opt_options) {\n  return abstract();\n};\n\n/**\n * Encode an array of features in this format.\n *\n * @abstract\n * @param {Array<import(\"../Feature.js\").default>} features Features.\n * @param {WriteOptions=} opt_options Write options.\n * @return {string} Result.\n */\nFeatureFormat.prototype.writeFeatures = function writeFeatures (features, opt_options) {\n  return abstract();\n};\n\n/**\n * Write a single geometry in this format.\n *\n * @abstract\n * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {WriteOptions=} opt_options Write options.\n * @return {string} Result.\n */\nFeatureFormat.prototype.writeGeometry = function writeGeometry (geometry, opt_options) {\n  return abstract();\n};\n\nexport default FeatureFormat;\n\n/**\n * @param {import(\"../geom/Geometry.js\").default|import(\"../extent.js\").Extent} geometry Geometry.\n * @param {boolean} write Set to true for writing, false for reading.\n * @param {(WriteOptions|ReadOptions)=} opt_options Options.\n * @return {import(\"../geom/Geometry.js\").default|import(\"../extent.js\").Extent} Transformed geometry.\n */\nexport function transformWithOptions(geometry, write, opt_options) {\n  var featureProjection = opt_options ?\n    getProjection(opt_options.featureProjection) : null;\n  var dataProjection = opt_options ?\n    getProjection(opt_options.dataProjection) : null;\n  /**\n   * @type {import(\"../geom/Geometry.js\").default|import(\"../extent.js\").Extent}\n   */\n  var transformed;\n  if (featureProjection && dataProjection &&\n      !equivalentProjection(featureProjection, dataProjection)) {\n    if (Array.isArray(geometry)) {\n      // FIXME this is necessary because GML treats extents\n      // as geometries\n      transformed = transformExtent(\n        geometry,\n        dataProjection,\n        featureProjection);\n    } else {\n      transformed = (write ? /** @type {import(\"../geom/Geometry\").default} */ (geometry).clone() : geometry).transform(\n        write ? featureProjection : dataProjection,\n        write ? dataProjection : featureProjection);\n    }\n  } else {\n    transformed = geometry;\n  }\n  if (write && opt_options && /** @type {WriteOptions} */ (opt_options).decimals !== undefined &&\n    !Array.isArray(transformed)) {\n    var power = Math.pow(10, /** @type {WriteOptions} */ (opt_options).decimals);\n    // if decimals option on write, round each coordinate appropriately\n    /**\n     * @param {Array<number>} coordinates Coordinates.\n     * @return {Array<number>} Transformed coordinates.\n     */\n    var transform = function(coordinates) {\n      for (var i = 0, ii = coordinates.length; i < ii; ++i) {\n        coordinates[i] = Math.round(coordinates[i] * power) / power;\n      }\n      return coordinates;\n    };\n    if (transformed === geometry) {\n      transformed = /** @type {import(\"../geom/Geometry\").default} */ (geometry).clone();\n    }\n    transformed.applyTransform(transform);\n  }\n  return transformed;\n}\n\n//# sourceMappingURL=Feature.js.map","/**\n * @module ol/format/XMLFeature\n */\nimport {abstract} from '../util.js';\nimport {extend} from '../array.js';\nimport FeatureFormat from '../format/Feature.js';\nimport FormatType from '../format/FormatType.js';\nimport {isDocument, parse} from '../xml.js';\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for XML feature formats.\n *\n * @abstract\n */\nvar XMLFeature = /*@__PURE__*/(function (FeatureFormat) {\n  function XMLFeature() {\n    FeatureFormat.call(this);\n\n    /**\n     * @type {XMLSerializer}\n     * @private\n     */\n    this.xmlSerializer_ = new XMLSerializer();\n  }\n\n  if ( FeatureFormat ) XMLFeature.__proto__ = FeatureFormat;\n  XMLFeature.prototype = Object.create( FeatureFormat && FeatureFormat.prototype );\n  XMLFeature.prototype.constructor = XMLFeature;\n\n  /**\n   * @inheritDoc\n   */\n  XMLFeature.prototype.getType = function getType () {\n    return FormatType.XML;\n  };\n\n  /**\n   * Read a single feature.\n   *\n   * @param {Document|Node|Object|string} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions=} opt_options Read options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   * @api\n   */\n  XMLFeature.prototype.readFeature = function readFeature (source, opt_options) {\n    if (!source) {\n      return null;\n    } else if (typeof source === 'string') {\n      var doc = parse(source);\n      return this.readFeatureFromDocument(doc, opt_options);\n    } else if (isDocument(source)) {\n      return this.readFeatureFromDocument(/** @type {Document} */ (source), opt_options);\n    } else {\n      return this.readFeatureFromNode(/** @type {Node} */ (source), opt_options);\n    }\n  };\n\n  /**\n   * @param {Document} doc Document.\n   * @param {import(\"./Feature.js\").ReadOptions=} opt_options Options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   */\n  XMLFeature.prototype.readFeatureFromDocument = function readFeatureFromDocument (doc, opt_options) {\n    var features = this.readFeaturesFromDocument(doc, opt_options);\n    if (features.length > 0) {\n      return features[0];\n    } else {\n      return null;\n    }\n  };\n\n  /**\n   * @param {Node} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions=} opt_options Options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   */\n  XMLFeature.prototype.readFeatureFromNode = function readFeatureFromNode (node, opt_options) {\n    return null; // not implemented\n  };\n\n  /**\n   * Read all features from a feature collection.\n   *\n   * @param {Document|Node|Object|string} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions=} opt_options Options.\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   * @api\n   */\n  XMLFeature.prototype.readFeatures = function readFeatures (source, opt_options) {\n    if (!source) {\n      return [];\n    } else if (typeof source === 'string') {\n      var doc = parse(source);\n      return this.readFeaturesFromDocument(doc, opt_options);\n    } else if (isDocument(source)) {\n      return this.readFeaturesFromDocument(\n        /** @type {Document} */ (source), opt_options);\n    } else {\n      return this.readFeaturesFromNode(/** @type {Node} */ (source), opt_options);\n    }\n  };\n\n  /**\n   * @param {Document} doc Document.\n   * @param {import(\"./Feature.js\").ReadOptions=} opt_options Options.\n   * @protected\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   */\n  XMLFeature.prototype.readFeaturesFromDocument = function readFeaturesFromDocument (doc, opt_options) {\n    /** @type {Array<import(\"../Feature.js\").default>} */\n    var features = [];\n    for (var n = /** @type {Node} */ (doc.firstChild); n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        extend(features, this.readFeaturesFromNode(n, opt_options));\n      }\n    }\n    return features;\n  };\n\n  /**\n   * @abstract\n   * @param {Node} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions=} opt_options Options.\n   * @protected\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   */\n  XMLFeature.prototype.readFeaturesFromNode = function readFeaturesFromNode (node, opt_options) {\n    return abstract();\n  };\n\n  /**\n   * @inheritDoc\n   */\n  XMLFeature.prototype.readGeometry = function readGeometry (source, opt_options) {\n    if (!source) {\n      return null;\n    } else if (typeof source === 'string') {\n      var doc = parse(source);\n      return this.readGeometryFromDocument(doc, opt_options);\n    } else if (isDocument(source)) {\n      return this.readGeometryFromDocument(\n        /** @type {Document} */ (source), opt_options);\n    } else {\n      return this.readGeometryFromNode(/** @type {Node} */ (source), opt_options);\n    }\n  };\n\n  /**\n   * @param {Document} doc Document.\n   * @param {import(\"./Feature.js\").ReadOptions=} opt_options Options.\n   * @protected\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  XMLFeature.prototype.readGeometryFromDocument = function readGeometryFromDocument (doc, opt_options) {\n    return null; // not implemented\n  };\n\n  /**\n   * @param {Node} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions=} opt_options Options.\n   * @protected\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  XMLFeature.prototype.readGeometryFromNode = function readGeometryFromNode (node, opt_options) {\n    return null; // not implemented\n  };\n\n  /**\n   * Read the projection from the source.\n   *\n   * @param {Document|Node|Object|string} source Source.\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   * @api\n   */\n  XMLFeature.prototype.readProjection = function readProjection (source) {\n    if (!source) {\n      return null;\n    } else if (typeof source === 'string') {\n      var doc = parse(source);\n      return this.readProjectionFromDocument(doc);\n    } else if (isDocument(source)) {\n      return this.readProjectionFromDocument(/** @type {Document} */ (source));\n    } else {\n      return this.readProjectionFromNode(/** @type {Node} */ (source));\n    }\n  };\n\n  /**\n   * @param {Document} doc Document.\n   * @protected\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */\n  XMLFeature.prototype.readProjectionFromDocument = function readProjectionFromDocument (doc) {\n    return this.dataProjection;\n  };\n\n  /**\n   * @param {Node} node Node.\n   * @protected\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */\n  XMLFeature.prototype.readProjectionFromNode = function readProjectionFromNode (node) {\n    return this.dataProjection;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  XMLFeature.prototype.writeFeature = function writeFeature (feature, opt_options) {\n    var node = this.writeFeatureNode(feature, opt_options);\n    return this.xmlSerializer_.serializeToString(node);\n  };\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"./Feature.js\").WriteOptions=} opt_options Options.\n   * @protected\n   * @return {Node} Node.\n   */\n  XMLFeature.prototype.writeFeatureNode = function writeFeatureNode (feature, opt_options) {\n    return null; // not implemented\n  };\n\n  /**\n   * Encode an array of features as string.\n   *\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions=} opt_options Write options.\n   * @return {string} Result.\n   * @api\n   */\n  XMLFeature.prototype.writeFeatures = function writeFeatures (features, opt_options) {\n    var node = this.writeFeaturesNode(features, opt_options);\n    return this.xmlSerializer_.serializeToString(node);\n  };\n\n  /**\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions=} opt_options Options.\n   * @return {Node} Node.\n   */\n  XMLFeature.prototype.writeFeaturesNode = function writeFeaturesNode (features, opt_options) {\n    return null; // not implemented\n  };\n\n  /**\n   * @inheritDoc\n   */\n  XMLFeature.prototype.writeGeometry = function writeGeometry (geometry, opt_options) {\n    var node = this.writeGeometryNode(geometry, opt_options);\n    return this.xmlSerializer_.serializeToString(node);\n  };\n\n  /**\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions=} opt_options Options.\n   * @return {Node} Node.\n   */\n  XMLFeature.prototype.writeGeometryNode = function writeGeometryNode (geometry, opt_options) {\n    return null; // not implemented\n  };\n\n  return XMLFeature;\n}(FeatureFormat));\n\n\nexport default XMLFeature;\n\n//# sourceMappingURL=XMLFeature.js.map","/**\n * @module ol/format/GPX\n */\nimport Feature from '../Feature.js';\nimport {includes} from '../array.js';\nimport {transformWithOptions} from './Feature.js';\nimport XMLFeature from './XMLFeature.js';\nimport {readString, readDecimal, readNonNegativeInteger, readDateTime, writeStringTextNode, writeNonNegativeIntegerTextNode, writeDecimalTextNode, writeDateTimeTextNode} from './xsd.js';\nimport GeometryLayout from '../geom/GeometryLayout.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport Point from '../geom/Point.js';\nimport {get as getProjection} from '../proj.js';\nimport {createElementNS, makeArrayPusher, makeArraySerializer, makeChildAppender,\n  makeObjectPropertySetter, makeSequence, makeSimpleNodeFactory, makeStructureNS,\n  OBJECT_PROPERTY_NODE_FACTORY, parseNode, pushParseAndPop, pushSerializeAndPop,\n  XML_SCHEMA_INSTANCE_URI} from '../xml.js';\n\n\n/**\n * @const\n * @type {Array<null|string>}\n */\nvar NAMESPACE_URIS = [\n  null,\n  'http://www.topografix.com/GPX/1/0',\n  'http://www.topografix.com/GPX/1/1'\n];\n\n\n/**\n * @const\n * @type {string}\n */\nvar SCHEMA_LOCATION = 'http://www.topografix.com/GPX/1/1 ' +\n    'http://www.topografix.com/GPX/1/1/gpx.xsd';\n\n\n/**\n * @const\n * @type {Object<string, function(Node, Array<*>): (Feature|undefined)>}\n */\nvar FEATURE_READER = {\n  'rte': readRte,\n  'trk': readTrk,\n  'wpt': readWpt\n};\n\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nvar GPX_PARSERS = makeStructureNS(\n  NAMESPACE_URIS, {\n    'rte': makeArrayPusher(readRte),\n    'trk': makeArrayPusher(readTrk),\n    'wpt': makeArrayPusher(readWpt)\n  });\n\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nvar LINK_PARSERS = makeStructureNS(\n  NAMESPACE_URIS, {\n    'text': makeObjectPropertySetter(readString, 'linkText'),\n    'type': makeObjectPropertySetter(readString, 'linkType')\n  });\n\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nvar GPX_SERIALIZERS = makeStructureNS(\n  NAMESPACE_URIS, {\n    'rte': makeChildAppender(writeRte),\n    'trk': makeChildAppender(writeTrk),\n    'wpt': makeChildAppender(writeWpt)\n  });\n\n\n/**\n * @typedef {Object} Options\n * @property {function(Feature, Node)} [readExtensions] Callback function\n * to process `extensions` nodes. To prevent memory leaks, this callback function must\n * not store any references to the node. Note that the `extensions`\n * node is not allowed in GPX 1.0. Moreover, only `extensions`\n * nodes from `wpt`, `rte` and `trk` can be processed, as those are\n * directly mapped to a feature.\n */\n\n/**\n * @typedef {Object} LayoutOptions\n * @property {boolean} [hasZ]\n * @property {boolean} [hasM]\n */\n\n/**\n * @classdesc\n * Feature format for reading and writing data in the GPX format.\n *\n * Note that {@link module:ol/format/GPX~GPX#readFeature} only reads the first\n * feature of the source.\n *\n * When reading, routes (`<rte>`) are converted into LineString geometries, and\n * tracks (`<trk>`) into MultiLineString. Any properties on route and track\n * waypoints are ignored.\n *\n * When writing, LineString geometries are output as routes (`<rte>`), and\n * MultiLineString as tracks (`<trk>`).\n *\n * @api\n */\nvar GPX = /*@__PURE__*/(function (XMLFeature) {\n  function GPX(opt_options) {\n    XMLFeature.call(this);\n\n    var options = opt_options ? opt_options : {};\n\n\n    /**\n     * @inheritDoc\n     */\n    this.dataProjection = getProjection('EPSG:4326');\n\n    /**\n     * @type {function(Feature, Node)|undefined}\n     * @private\n     */\n    this.readExtensions_ = options.readExtensions;\n  }\n\n  if ( XMLFeature ) GPX.__proto__ = XMLFeature;\n  GPX.prototype = Object.create( XMLFeature && XMLFeature.prototype );\n  GPX.prototype.constructor = GPX;\n\n  /**\n   * @param {Array<Feature>} features List of features.\n   * @private\n   */\n  GPX.prototype.handleReadExtensions_ = function handleReadExtensions_ (features) {\n    if (!features) {\n      features = [];\n    }\n    for (var i = 0, ii = features.length; i < ii; ++i) {\n      var feature = features[i];\n      if (this.readExtensions_) {\n        var extensionsNode = feature.get('extensionsNode_') || null;\n        this.readExtensions_(feature, extensionsNode);\n      }\n      feature.set('extensionsNode_', undefined);\n    }\n  };\n\n  /**\n   * @inheritDoc\n   */\n  GPX.prototype.readFeatureFromNode = function readFeatureFromNode (node, opt_options) {\n    if (!includes(NAMESPACE_URIS, node.namespaceURI)) {\n      return null;\n    }\n    var featureReader = FEATURE_READER[node.localName];\n    if (!featureReader) {\n      return null;\n    }\n    var feature = featureReader(node, [this.getReadOptions(node, opt_options)]);\n    if (!feature) {\n      return null;\n    }\n    this.handleReadExtensions_([feature]);\n    return feature;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  GPX.prototype.readFeaturesFromNode = function readFeaturesFromNode (node, opt_options) {\n    if (!includes(NAMESPACE_URIS, node.namespaceURI)) {\n      return [];\n    }\n    if (node.localName == 'gpx') {\n      /** @type {Array<Feature>} */\n      var features = pushParseAndPop([], GPX_PARSERS,\n        node, [this.getReadOptions(node, opt_options)]);\n      if (features) {\n        this.handleReadExtensions_(features);\n        return features;\n      } else {\n        return [];\n      }\n    }\n    return [];\n  };\n\n  /**\n   * Encode an array of features in the GPX format as an XML node.\n   * LineString geometries are output as routes (`<rte>`), and MultiLineString\n   * as tracks (`<trk>`).\n   *\n   * @param {Array<Feature>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions=} opt_options Options.\n   * @return {Node} Node.\n   * @override\n   * @api\n   */\n  GPX.prototype.writeFeaturesNode = function writeFeaturesNode (features, opt_options) {\n    opt_options = this.adaptOptions(opt_options);\n    //FIXME Serialize metadata\n    var gpx = createElementNS('http://www.topografix.com/GPX/1/1', 'gpx');\n    var xmlnsUri = 'http://www.w3.org/2000/xmlns/';\n    gpx.setAttributeNS(xmlnsUri, 'xmlns:xsi', XML_SCHEMA_INSTANCE_URI);\n    gpx.setAttributeNS(XML_SCHEMA_INSTANCE_URI, 'xsi:schemaLocation', SCHEMA_LOCATION);\n    gpx.setAttribute('version', '1.1');\n    gpx.setAttribute('creator', 'OpenLayers');\n\n    pushSerializeAndPop(/** @type {import(\"../xml.js\").NodeStackItem} */\n      ({node: gpx}), GPX_SERIALIZERS, GPX_NODE_FACTORY, features, [opt_options]);\n    return gpx;\n  };\n\n  return GPX;\n}(XMLFeature));\n\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nvar RTE_PARSERS = makeStructureNS(\n  NAMESPACE_URIS, {\n    'name': makeObjectPropertySetter(readString),\n    'cmt': makeObjectPropertySetter(readString),\n    'desc': makeObjectPropertySetter(readString),\n    'src': makeObjectPropertySetter(readString),\n    'link': parseLink,\n    'number': makeObjectPropertySetter(readNonNegativeInteger),\n    'extensions': parseExtensions,\n    'type': makeObjectPropertySetter(readString),\n    'rtept': parseRtePt\n  });\n\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nvar RTEPT_PARSERS = makeStructureNS(\n  NAMESPACE_URIS, {\n    'ele': makeObjectPropertySetter(readDecimal),\n    'time': makeObjectPropertySetter(readDateTime)\n  });\n\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nvar TRK_PARSERS = makeStructureNS(\n  NAMESPACE_URIS, {\n    'name': makeObjectPropertySetter(readString),\n    'cmt': makeObjectPropertySetter(readString),\n    'desc': makeObjectPropertySetter(readString),\n    'src': makeObjectPropertySetter(readString),\n    'link': parseLink,\n    'number': makeObjectPropertySetter(readNonNegativeInteger),\n    'type': makeObjectPropertySetter(readString),\n    'extensions': parseExtensions,\n    'trkseg': parseTrkSeg\n  });\n\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nvar TRKSEG_PARSERS = makeStructureNS(\n  NAMESPACE_URIS, {\n    'trkpt': parseTrkPt\n  });\n\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nvar TRKPT_PARSERS = makeStructureNS(\n  NAMESPACE_URIS, {\n    'ele': makeObjectPropertySetter(readDecimal),\n    'time': makeObjectPropertySetter(readDateTime)\n  });\n\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nvar WPT_PARSERS = makeStructureNS(\n  NAMESPACE_URIS, {\n    'ele': makeObjectPropertySetter(readDecimal),\n    'time': makeObjectPropertySetter(readDateTime),\n    'magvar': makeObjectPropertySetter(readDecimal),\n    'geoidheight': makeObjectPropertySetter(readDecimal),\n    'name': makeObjectPropertySetter(readString),\n    'cmt': makeObjectPropertySetter(readString),\n    'desc': makeObjectPropertySetter(readString),\n    'src': makeObjectPropertySetter(readString),\n    'link': parseLink,\n    'sym': makeObjectPropertySetter(readString),\n    'type': makeObjectPropertySetter(readString),\n    'fix': makeObjectPropertySetter(readString),\n    'sat': makeObjectPropertySetter(readNonNegativeInteger),\n    'hdop': makeObjectPropertySetter(readDecimal),\n    'vdop': makeObjectPropertySetter(readDecimal),\n    'pdop': makeObjectPropertySetter(readDecimal),\n    'ageofdgpsdata': makeObjectPropertySetter(readDecimal),\n    'dgpsid': makeObjectPropertySetter(readNonNegativeInteger),\n    'extensions': parseExtensions\n  });\n\n\n/**\n * @const\n * @type {Array<string>}\n */\nvar LINK_SEQUENCE = ['text', 'type'];\n\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nvar LINK_SERIALIZERS = makeStructureNS(\n  NAMESPACE_URIS, {\n    'text': makeChildAppender(writeStringTextNode),\n    'type': makeChildAppender(writeStringTextNode)\n  });\n\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\nvar RTE_SEQUENCE = makeStructureNS(\n  NAMESPACE_URIS, [\n    'name', 'cmt', 'desc', 'src', 'link', 'number', 'type', 'rtept'\n  ]);\n\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nvar RTE_SERIALIZERS = makeStructureNS(\n  NAMESPACE_URIS, {\n    'name': makeChildAppender(writeStringTextNode),\n    'cmt': makeChildAppender(writeStringTextNode),\n    'desc': makeChildAppender(writeStringTextNode),\n    'src': makeChildAppender(writeStringTextNode),\n    'link': makeChildAppender(writeLink),\n    'number': makeChildAppender(writeNonNegativeIntegerTextNode),\n    'type': makeChildAppender(writeStringTextNode),\n    'rtept': makeArraySerializer(makeChildAppender(writeWptType))\n  });\n\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\nvar RTEPT_TYPE_SEQUENCE = makeStructureNS(\n  NAMESPACE_URIS, [\n    'ele', 'time'\n  ]);\n\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\nvar TRK_SEQUENCE = makeStructureNS(\n  NAMESPACE_URIS, [\n    'name', 'cmt', 'desc', 'src', 'link', 'number', 'type', 'trkseg'\n  ]);\n\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nvar TRK_SERIALIZERS = makeStructureNS(\n  NAMESPACE_URIS, {\n    'name': makeChildAppender(writeStringTextNode),\n    'cmt': makeChildAppender(writeStringTextNode),\n    'desc': makeChildAppender(writeStringTextNode),\n    'src': makeChildAppender(writeStringTextNode),\n    'link': makeChildAppender(writeLink),\n    'number': makeChildAppender(writeNonNegativeIntegerTextNode),\n    'type': makeChildAppender(writeStringTextNode),\n    'trkseg': makeArraySerializer(makeChildAppender(writeTrkSeg))\n  });\n\n\n/**\n * @const\n * @type {function(*, Array<*>, string=): (Node|undefined)}\n */\nvar TRKSEG_NODE_FACTORY = makeSimpleNodeFactory('trkpt');\n\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nvar TRKSEG_SERIALIZERS = makeStructureNS(\n  NAMESPACE_URIS, {\n    'trkpt': makeChildAppender(writeWptType)\n  });\n\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\nvar WPT_TYPE_SEQUENCE = makeStructureNS(\n  NAMESPACE_URIS, [\n    'ele', 'time', 'magvar', 'geoidheight', 'name', 'cmt', 'desc', 'src',\n    'link', 'sym', 'type', 'fix', 'sat', 'hdop', 'vdop', 'pdop',\n    'ageofdgpsdata', 'dgpsid'\n  ]);\n\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nvar WPT_TYPE_SERIALIZERS = makeStructureNS(\n  NAMESPACE_URIS, {\n    'ele': makeChildAppender(writeDecimalTextNode),\n    'time': makeChildAppender(writeDateTimeTextNode),\n    'magvar': makeChildAppender(writeDecimalTextNode),\n    'geoidheight': makeChildAppender(writeDecimalTextNode),\n    'name': makeChildAppender(writeStringTextNode),\n    'cmt': makeChildAppender(writeStringTextNode),\n    'desc': makeChildAppender(writeStringTextNode),\n    'src': makeChildAppender(writeStringTextNode),\n    'link': makeChildAppender(writeLink),\n    'sym': makeChildAppender(writeStringTextNode),\n    'type': makeChildAppender(writeStringTextNode),\n    'fix': makeChildAppender(writeStringTextNode),\n    'sat': makeChildAppender(writeNonNegativeIntegerTextNode),\n    'hdop': makeChildAppender(writeDecimalTextNode),\n    'vdop': makeChildAppender(writeDecimalTextNode),\n    'pdop': makeChildAppender(writeDecimalTextNode),\n    'ageofdgpsdata': makeChildAppender(writeDecimalTextNode),\n    'dgpsid': makeChildAppender(writeNonNegativeIntegerTextNode)\n  });\n\n\n/**\n * @const\n * @type {Object<string, string>}\n */\nvar GEOMETRY_TYPE_TO_NODENAME = {\n  'Point': 'wpt',\n  'LineString': 'rte',\n  'MultiLineString': 'trk'\n};\n\n\n/**\n * @param {*} value Value.\n * @param {Array<*>} objectStack Object stack.\n * @param {string=} opt_nodeName Node name.\n * @return {Node|undefined} Node.\n */\nfunction GPX_NODE_FACTORY(value, objectStack, opt_nodeName) {\n  var geometry = /** @type {Feature} */ (value).getGeometry();\n  if (geometry) {\n    var nodeName = GEOMETRY_TYPE_TO_NODENAME[geometry.getType()];\n    if (nodeName) {\n      var parentNode = objectStack[objectStack.length - 1].node;\n      return createElementNS(parentNode.namespaceURI, nodeName);\n    }\n  }\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {LayoutOptions} layoutOptions Layout options.\n * @param {Element} node Node.\n * @param {!Object} values Values.\n * @return {Array<number>} Flat coordinates.\n */\nfunction appendCoordinate(flatCoordinates, layoutOptions, node, values) {\n  flatCoordinates.push(\n    parseFloat(node.getAttribute('lon')),\n    parseFloat(node.getAttribute('lat')));\n  if ('ele' in values) {\n    flatCoordinates.push(/** @type {number} */ (values['ele']));\n    delete values['ele'];\n    layoutOptions.hasZ = true;\n  } else {\n    flatCoordinates.push(0);\n  }\n  if ('time' in values) {\n    flatCoordinates.push(/** @type {number} */ (values['time']));\n    delete values['time'];\n    layoutOptions.hasM = true;\n  } else {\n    flatCoordinates.push(0);\n  }\n  return flatCoordinates;\n}\n\n\n/**\n * Choose GeometryLayout based on flags in layoutOptions and adjust flatCoordinates\n * and ends arrays by shrinking them accordingly (removing unused zero entries).\n *\n * @param {LayoutOptions} layoutOptions Layout options.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {Array<number>=} ends Ends.\n * @return {GeometryLayout} Layout.\n */\nfunction applyLayoutOptions(layoutOptions, flatCoordinates, ends) {\n  var layout = GeometryLayout.XY;\n  var stride = 2;\n  if (layoutOptions.hasZ && layoutOptions.hasM) {\n    layout = GeometryLayout.XYZM;\n    stride = 4;\n  } else if (layoutOptions.hasZ) {\n    layout = GeometryLayout.XYZ;\n    stride = 3;\n  } else if (layoutOptions.hasM) {\n    layout = GeometryLayout.XYM;\n    stride = 3;\n  }\n  if (stride !== 4) {\n    for (var i = 0, ii = flatCoordinates.length / 4; i < ii; i++) {\n      flatCoordinates[i * stride] = flatCoordinates[i * 4];\n      flatCoordinates[i * stride + 1] = flatCoordinates[i * 4 + 1];\n      if (layoutOptions.hasZ) {\n        flatCoordinates[i * stride + 2] = flatCoordinates[i * 4 + 2];\n      }\n      if (layoutOptions.hasM) {\n        flatCoordinates[i * stride + 2] = flatCoordinates[i * 4 + 3];\n      }\n    }\n    flatCoordinates.length = flatCoordinates.length / 4 * stride;\n    if (ends) {\n      for (var i$1 = 0, ii$1 = ends.length; i$1 < ii$1; i$1++) {\n        ends[i$1] = ends[i$1] / 4 * stride;\n      }\n    }\n  }\n  return layout;\n}\n\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction parseLink(node, objectStack) {\n  var values = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  var href = node.getAttribute('href');\n  if (href !== null) {\n    values['link'] = href;\n  }\n  parseNode(LINK_PARSERS, node, objectStack);\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction parseExtensions(node, objectStack) {\n  var values = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  values['extensionsNode_'] = node;\n}\n\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction parseRtePt(node, objectStack) {\n  var values = pushParseAndPop({}, RTEPT_PARSERS, node, objectStack);\n  if (values) {\n    var rteValues = /** @type {!Object} */ (objectStack[objectStack.length - 1]);\n    var flatCoordinates = /** @type {Array<number>} */ (rteValues['flatCoordinates']);\n    var layoutOptions = /** @type {LayoutOptions} */ (rteValues['layoutOptions']);\n    appendCoordinate(flatCoordinates, layoutOptions, node, values);\n  }\n}\n\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction parseTrkPt(node, objectStack) {\n  var values = pushParseAndPop({}, TRKPT_PARSERS, node, objectStack);\n  if (values) {\n    var trkValues = /** @type {!Object} */ (objectStack[objectStack.length - 1]);\n    var flatCoordinates = /** @type {Array<number>} */ (trkValues['flatCoordinates']);\n    var layoutOptions = /** @type {LayoutOptions} */ (trkValues['layoutOptions']);\n    appendCoordinate(flatCoordinates, layoutOptions, node, values);\n  }\n}\n\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction parseTrkSeg(node, objectStack) {\n  var values = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  parseNode(TRKSEG_PARSERS, node, objectStack);\n  var flatCoordinates = /** @type {Array<number>} */\n      (values['flatCoordinates']);\n  var ends = /** @type {Array<number>} */ (values['ends']);\n  ends.push(flatCoordinates.length);\n}\n\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Feature|undefined} Track.\n */\nfunction readRte(node, objectStack) {\n  var options = /** @type {import(\"./Feature.js\").ReadOptions} */ (objectStack[0]);\n  var values = pushParseAndPop({\n    'flatCoordinates': [],\n    'layoutOptions': {}\n  }, RTE_PARSERS, node, objectStack);\n  if (!values) {\n    return undefined;\n  }\n  var flatCoordinates = /** @type {Array<number>} */\n      (values['flatCoordinates']);\n  delete values['flatCoordinates'];\n  var layoutOptions = /** @type {LayoutOptions} */ (values['layoutOptions']);\n  delete values['layoutOptions'];\n  var layout = applyLayoutOptions(layoutOptions, flatCoordinates);\n  var geometry = new LineString(flatCoordinates, layout);\n  transformWithOptions(geometry, false, options);\n  var feature = new Feature(geometry);\n  feature.setProperties(values);\n  return feature;\n}\n\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Feature|undefined} Track.\n */\nfunction readTrk(node, objectStack) {\n  var options = /** @type {import(\"./Feature.js\").ReadOptions} */ (objectStack[0]);\n  var values = pushParseAndPop({\n    'flatCoordinates': [],\n    'ends': [],\n    'layoutOptions': {}\n  }, TRK_PARSERS, node, objectStack);\n  if (!values) {\n    return undefined;\n  }\n  var flatCoordinates = /** @type {Array<number>} */\n      (values['flatCoordinates']);\n  delete values['flatCoordinates'];\n  var ends = /** @type {Array<number>} */ (values['ends']);\n  delete values['ends'];\n  var layoutOptions = /** @type {LayoutOptions} */ (values['layoutOptions']);\n  delete values['layoutOptions'];\n  var layout = applyLayoutOptions(layoutOptions, flatCoordinates, ends);\n  var geometry = new MultiLineString(flatCoordinates, layout, ends);\n  transformWithOptions(geometry, false, options);\n  var feature = new Feature(geometry);\n  feature.setProperties(values);\n  return feature;\n}\n\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Feature|undefined} Waypoint.\n */\nfunction readWpt(node, objectStack) {\n  var options = /** @type {import(\"./Feature.js\").ReadOptions} */ (objectStack[0]);\n  var values = pushParseAndPop({}, WPT_PARSERS, node, objectStack);\n  if (!values) {\n    return undefined;\n  }\n  var layoutOptions = /** @type {LayoutOptions} */ ({});\n  var coordinates = appendCoordinate([], layoutOptions, node, values);\n  var layout = applyLayoutOptions(layoutOptions, coordinates);\n  var geometry = new Point(coordinates, layout);\n  transformWithOptions(geometry, false, options);\n  var feature = new Feature(geometry);\n  feature.setProperties(values);\n  return feature;\n}\n\n\n/**\n * @param {Element} node Node.\n * @param {string} value Value for the link's `href` attribute.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeLink(node, value, objectStack) {\n  node.setAttribute('href', value);\n  var context = objectStack[objectStack.length - 1];\n  var properties = context['properties'];\n  var link = [\n    properties['linkText'],\n    properties['linkType']\n  ];\n  pushSerializeAndPop(/** @type {import(\"../xml.js\").NodeStackItem} */ ({node: node}),\n    LINK_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY,\n    link, objectStack, LINK_SEQUENCE);\n}\n\n\n/**\n * @param {Element} node Node.\n * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeWptType(node, coordinate, objectStack) {\n  var context = objectStack[objectStack.length - 1];\n  var parentNode = context.node;\n  var namespaceURI = parentNode.namespaceURI;\n  var properties = context['properties'];\n  //FIXME Projection handling\n  node.setAttributeNS(null, 'lat', String(coordinate[1]));\n  node.setAttributeNS(null, 'lon', String(coordinate[0]));\n  var geometryLayout = context['geometryLayout'];\n  switch (geometryLayout) {\n    case GeometryLayout.XYZM:\n      if (coordinate[3] !== 0) {\n        properties['time'] = coordinate[3];\n      }\n      // fall through\n    case GeometryLayout.XYZ:\n      if (coordinate[2] !== 0) {\n        properties['ele'] = coordinate[2];\n      }\n      break;\n    case GeometryLayout.XYM:\n      if (coordinate[2] !== 0) {\n        properties['time'] = coordinate[2];\n      }\n      break;\n    default:\n      // pass\n  }\n  var orderedKeys = (node.nodeName == 'rtept') ?\n    RTEPT_TYPE_SEQUENCE[namespaceURI] :\n    WPT_TYPE_SEQUENCE[namespaceURI];\n  var values = makeSequence(properties, orderedKeys);\n  pushSerializeAndPop(/** @type {import(\"../xml.js\").NodeStackItem} */\n    ({node: node, 'properties': properties}),\n    WPT_TYPE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY,\n    values, objectStack, orderedKeys);\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {Feature} feature Feature.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeRte(node, feature, objectStack) {\n  var options = /** @type {import(\"./Feature.js\").WriteOptions} */ (objectStack[0]);\n  var properties = feature.getProperties();\n  var context = {node: node};\n  context['properties'] = properties;\n  var geometry = feature.getGeometry();\n  if (geometry.getType() == GeometryType.LINE_STRING) {\n    var lineString = /** @type {LineString} */ (transformWithOptions(geometry, true, options));\n    context['geometryLayout'] = lineString.getLayout();\n    properties['rtept'] = lineString.getCoordinates();\n  }\n  var parentNode = objectStack[objectStack.length - 1].node;\n  var orderedKeys = RTE_SEQUENCE[parentNode.namespaceURI];\n  var values = makeSequence(properties, orderedKeys);\n  pushSerializeAndPop(context,\n    RTE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY,\n    values, objectStack, orderedKeys);\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {Feature} feature Feature.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeTrk(node, feature, objectStack) {\n  var options = /** @type {import(\"./Feature.js\").WriteOptions} */ (objectStack[0]);\n  var properties = feature.getProperties();\n  /** @type {import(\"../xml.js\").NodeStackItem} */\n  var context = {node: node};\n  context['properties'] = properties;\n  var geometry = feature.getGeometry();\n  if (geometry.getType() == GeometryType.MULTI_LINE_STRING) {\n    var multiLineString = /** @type {MultiLineString} */ (transformWithOptions(geometry, true, options));\n    properties['trkseg'] = multiLineString.getLineStrings();\n  }\n  var parentNode = objectStack[objectStack.length - 1].node;\n  var orderedKeys = TRK_SEQUENCE[parentNode.namespaceURI];\n  var values = makeSequence(properties, orderedKeys);\n  pushSerializeAndPop(context,\n    TRK_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY,\n    values, objectStack, orderedKeys);\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {LineString} lineString LineString.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeTrkSeg(node, lineString, objectStack) {\n  /** @type {import(\"../xml.js\").NodeStackItem} */\n  var context = {node: node};\n  context['geometryLayout'] = lineString.getLayout();\n  context['properties'] = {};\n  pushSerializeAndPop(context,\n    TRKSEG_SERIALIZERS, TRKSEG_NODE_FACTORY,\n    lineString.getCoordinates(), objectStack);\n}\n\n\n/**\n * @param {Element} node Node.\n * @param {Feature} feature Feature.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeWpt(node, feature, objectStack) {\n  var options = /** @type {import(\"./Feature.js\").WriteOptions} */ (objectStack[0]);\n  var context = objectStack[objectStack.length - 1];\n  context['properties'] = feature.getProperties();\n  var geometry = feature.getGeometry();\n  if (geometry.getType() == GeometryType.POINT) {\n    var point = /** @type {Point} */ (transformWithOptions(geometry, true, options));\n    context['geometryLayout'] = point.getLayout();\n    writeWptType(node, point.getCoordinates(), objectStack);\n  }\n}\n\n\nexport default GPX;\n\n//# sourceMappingURL=GPX.js.map","/*\tCopyright (c) 2015 Jean-Marc VIGLINO, \n\treleased under the CeCILL-B license (French BSD license)\n\t(http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt).\n*\n*  Shadow image style for point vector features\n*/\n\nimport {inherits as ol_inherits} from 'ol'\nimport ol_style_Fill from 'ol/style/Fill'\nimport ol_style_RegularShape from 'ol/style/RegularShape'\n\n/**\n * @requires ol.style.Circle\n * @requires ol.structs.IHasChecksum\n */\n\n\n/**\n * @classdesc\n * Set Shadow style for point vector features.\n *\n * @constructor\n * @param {} options Options.\n *   @param {ol.style.Fill | undefined} options.fill fill style, default rgba(0,0,0,0.5)\n *   @param {number} options.radius point radius\n * \t @param {number} options.blur lur radius, default radius/3\n * \t @param {number} options.offsetX x offset, default 0\n * \t @param {number} options.offsetY y offset, default 0\n * @extends {ol_style_RegularShape}\n * @implements {ol.structs.IHasChecksum}\n * @api\n */\nvar ol_style_Shadow = function(options)\n{\toptions = options || {};\n\tif (!options.fill) options.fill = new ol_style_Fill({ color: \"rgba(0,0,0,0.5)\" });\n\tol_style_RegularShape.call (this,{ radius: options.radius, fill: options.fill });\n\n\tthis.fill_ = options.fill;\n\tthis.radius_ = options.radius;\n\tthis.blur_ = options.blur===0 ? 0 : options.blur || options.radius/3;\n\tthis.offset_ = [options.offsetX ? options.offsetX : 0, options.offsetY ? options.offsetY : 0];\n\n\tthis.renderShadow_();\n};\nol_inherits(ol_style_Shadow, ol_style_RegularShape);\n\n/**\n * Clones the style. \n * @return {ol_style_Shadow}\n */\nol_style_Shadow.prototype.clone = function()\n{\tvar s = new ol_style_Shadow(\n\t{\tfill: this.fill_,\n\t\tradius: this.radius_,\n\t\tblur: this.blur_,\n\t\toffsetX: this.offset_[0],\n\t\toffsetY: this.offset_[1]\n\t});\n\ts.setScale(this.getScale());\n\ts.setOpacity(this.getOpacity());\n\treturn s;\n};\n\n/**\n * @private\n */\nol_style_Shadow.prototype.renderShadow_ = function()\n{\t\n\tvar radius = this.radius_;\n\t\n\tvar canvas = this.getImage();\n\tvar s = [canvas.width, canvas.height];\n\ts[1] = radius;\n\t// Remove the circle on the canvas\n\tvar context = (canvas.getContext('2d'));\n\n\tcontext.beginPath();\n\tcontext.clearRect(0, 0, canvas.width, canvas.height);\n\n\tcontext.scale(1,0.5);\n\tcontext.arc(radius, -radius, radius-this.blur_, 0, 2 * Math.PI, false);\n    context.fillStyle = '#000';\n\n\tcontext.shadowColor = this.fill_.getColor();\n\tcontext.shadowBlur = 0.7*this.blur_;\n\tcontext.shadowOffsetX = 0;\n\tcontext.shadowOffsetY = 1.5*radius;\n\n\tcontext.closePath();\n    context.fill();\n\n\tcontext.shadowColor = 'transparent';\n    \n\t// Set anchor\n\tvar a = this.getAnchor();\n\ta[0] = canvas.width /2 -this.offset_[0];\n\ta[1] = canvas.height/2 -this.offset_[1];\n}\n\n\n/**\n * @inheritDoc\n */\nol_style_Shadow.prototype.getChecksum = function()\n{\n\tvar strokeChecksum = (this.stroke_!==null) ?\n\t\tthis.stroke_.getChecksum() : '-';\n\tvar fillChecksum = (this.fill_!==null) ?\n\t\tthis.fill_.getChecksum() : '-';\n\n\tvar recalculate = (this.checksums_===null) ||\n\t\t(strokeChecksum != this.checksums_[1] ||\n\t\tfillChecksum != this.checksums_[2] ||\n\t\tthis.radius_ != this.checksums_[3] ||\n\t\tthis.form_+\"-\"+this.glyphs_ != this.checksums_[4]);\n\n\tif (recalculate) {\n\t\tvar checksum = 'c' + strokeChecksum + fillChecksum \n\t\t\t+ ((this.radius_ !== void 0) ? this.radius_.toString() : '-')\n\t\t\t+ this.form_+\"-\"+this.glyphs_;\n\t\tthis.checksums_ = [checksum, strokeChecksum, fillChecksum, this.radius_, this.form_+\"-\"+this.glyphs_];\n\t}\n\n\treturn this.checksums_[0];\n};\n\nexport default ol_style_Shadow\n","/*\n\tCopyright (c) 2016 Jean-Marc VIGLINO, \n\treleased under the CeCILL license (http://www.cecill.info/).\n*/\n\nimport {inherits as ol_inherits} from 'ol'\nimport ol_Object from 'ol/Object'\nimport {linear as ol_easing_linear} from 'ol/easing'\nimport ol_Map from 'ol/Map'\nimport ol_layer_Vector from 'ol/layer/Vector'\nimport {getCenter as ol_extent_getCenter} from 'ol/extent'\nimport {unByKey as ol_Observable_unByKey} from 'ol/Observable'\n\n/** Feature animation base class\n * Use the {@link _ol_Map_#animateFeature} or {@link _ol_layer_Vector_#animateFeature} to animate a feature\n * on postcompose in a map or a layer\n* @constructor\n* @fires animationstart|animationend\n* @param {ol_featureAnimationOptions} options\n*\t@param {Number} options.duration duration of the animation in ms, default 1000\n*\t@param {bool} options.revers revers the animation direction\n*\t@param {Number} options.repeat number of time to repeat the animation, default 0\n*\t@param {oo.style.Style} options.hiddenStyle a style to display the feature when playing the animation\n*\t\tto be used to make the feature selectable when playing animation \n*\t\t(@see {@link ../examples/map.featureanimation.select.html}), default the feature \n*\t\twill be hidden when playing (and niot selectable)\n*\t@param {ol_easing_Function} options.fade an easing function used to fade in the feature, default none\n*\t@param {ol_easing_Function} options.easing an easing function for the animation, default ol_easing_linear\n*/\nvar ol_featureAnimation = function(options)\n{\toptions = options || {};\n\t\n\tthis.duration_ = typeof (options.duration)=='number' ? (options.duration>=0 ? options.duration : 0) : 1000;\n\tthis.fade_ = typeof(options.fade) == 'function' ? options.fade : null;\n\tthis.repeat_ = Number(options.repeat);\n\n\tvar easing = typeof(options.easing) =='function' ? options.easing : ol_easing_linear;\n\tif (options.revers) this.easing_ = function(t) { return (1 - easing(t)); };\n\telse this.easing_ = easing;\n\n\tthis.hiddenStyle = options.hiddenStyle;\n\n\tol_Object.call(this);\n};\nol_inherits(ol_featureAnimation, ol_Object);\n\n/** Draw a geometry \n* @param {olx.animateFeatureEvent} e\n* @param {ol.geom} geom geometry for shadow\n* @param {ol.geom} shadow geometry for shadow (ie. style with zIndex = -1)\n* @private\n*/\nol_featureAnimation.prototype.drawGeom_ = function (e, geom, shadow)\n{\tif (this.fade_) \n\t{\te.context.globalAlpha = this.fade_(1-e.elapsed);\n\t}\n\tvar style = e.style;\n\tfor (var i=0; i<style.length; i++)\n\t{\tvar sc=0;\n\t\t// OL < v4.3 : setImageStyle doesn't check retina\n\t\tvar imgs = ol_Map.prototype.getFeaturesAtPixel ? false : style[i].getImage();\n\t\tif (imgs) \n\t\t{\tsc = imgs.getScale(); \n\t\t\timgs.setScale(e.frameState.pixelRatio*sc);\n\t\t}\n\t\t// Prevent crach if the style is not ready (image not loaded)\n\t\ttry{\n\t\t\te.vectorContext.setStyle(style[i]);\n\t\t\tif (style[i].getZIndex()<0) e.vectorContext.drawGeometry(shadow||geom);\n\t\t\telse e.vectorContext.drawGeometry(geom);\n\t\t} catch(e) { /* ok */ }\n\t\tif (imgs) imgs.setScale(sc);\n\t}\n};\n\n/** Function to perform manipulations onpostcompose. \n * This function is called with an ol_featureAnimationEvent argument.\n * The function will be overridden by the child implementation.    \n * Return true to keep this function for the next frame, false to remove it.\n * @param {ol_featureAnimationEvent} e\n * @return {bool} true to continue animation.\n * @api \n */\nol_featureAnimation.prototype.animate = function (/* e */)\n{\treturn false;\n};\n\n/** An animation controler object an object to control animation with start, stop and isPlaying function.    \n * To be used with {@link olx.Map#animateFeature} or {@link ol.layer.Vector#animateFeature}\n * @typedef {Object} ol.animationControler\n * @property {function} start - start animation.\n * @property {function} stop - stop animation option arguments can be passed in animationend event.\n * @property {function} isPlaying - return true if animation is playing.\n */\n\n/** Animate feature on a map\n * @function \n * @fires animationstart, animationend\n * @param {ol.Feature} feature Feature to animate\n * @param {ol_featureAnimation|Array<ol_featureAnimation>} fanim the animation to play\n * @return {olx.animationControler} an object to control animation with start, stop and isPlaying function\n */\nol_Map.prototype.animateFeature =\n\n/** Animate feature on a vector layer \n * @fires animationstart, animationend\n * @param {ol.Feature} feature Feature to animate\n * @param {ol_featureAnimation|Array<ol_featureAnimation>} fanim the animation to play\n * @return {olx.animationControler} an object to control animation with start, stop and isPlaying function\n*/\nol_layer_Vector.prototype.animateFeature = function(feature, fanim)\n{\tvar self = this;\n\tvar listenerKey;\n\t\n\t// Save style\n\tvar style = feature.getStyle();\n\tvar flashStyle = style || (this.getStyleFunction ? this.getStyleFunction()(feature) : null);\n\tif (!flashStyle) flashStyle=[];\n\tif (!(flashStyle instanceof Array)) flashStyle = [flashStyle];\n\n\t// Hide feature while animating\n\tfeature.setStyle(fanim.hiddenStyle || []);\n\n\t// Structure pass for animating\n\tvar event = \n\t\t{\t// Frame context\n\t\t\tvectorContext: null,\n\t\t\tframeState: null,\n\t\t\tstart: 0,\n\t\t\ttime: 0,\n\t\t\telapsed: 0,\n\t\t\textent: false,\n\t\t\t// Feature information\n\t\t\tfeature: feature,\n\t\t\tgeom: feature.getGeometry(),\n\t\t\ttypeGeom: feature.getGeometry().getType(),\n\t\t\tbbox: feature.getGeometry().getExtent(),\n\t\t\tcoord: ol_extent_getCenter(feature.getGeometry().getExtent()),\n\t\t\tstyle: flashStyle\n\t\t};\n\n\tif (!(fanim instanceof Array)) fanim = [fanim];\n\t// Remove null animations\n\tfor (var i=fanim.length-1; i>=0; i--)\n\t{\tif (fanim[i].duration_===0) fanim.splice(i,1);\n\t}\n\n\tvar nb=0, step = 0;\n\n\tfunction animate(e) \n\t{\tevent.vectorContext = e.vectorContext;\n\t\tevent.frameState = e.frameState;\n\t\tif (!event.extent) \n\t\t{\tevent.extent = e.frameState.extent;\n\t\t\tevent.start = e.frameState.time;\n\t\t\tevent.context = e.context;\n\t\t}\n\t\tevent.time = e.frameState.time - event.start;\n\t\tevent.elapsed = event.time / fanim[step].duration_;\n\t\tif (event.elapsed > 1) event.elapsed = 1;\n\t\t\n\t\t// Stop animation?\n\t\tif (!fanim[step].animate(event))\n\t\t{\tnb++;\n\t\t\t// Repeat animation\n\t\t\tif (nb < fanim[step].repeat_)\n\t\t\t{\tevent.extent = false;\n\t\t\t}\n\t\t\t// newt step\n\t\t\telse if (step < fanim.length-1)\n\t\t\t{\tfanim[step].dispatchEvent({ type:'animationend', feature: feature });\n\t\t\t\tstep++;\n\t\t\t\tnb=0;\n\t\t\t\tevent.extent = false;\n\t\t\t}\n\t\t\t// the end\n\t\t\telse \n\t\t\t{\tstop();\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t\t// tell OL3 to continue postcompose animation\n\t\te.frameState.animate = true;\n\t}\n\n\t// Stop animation\n\tfunction stop(options)\n\t{\tol_Observable_unByKey(listenerKey);\n\t\tlistenerKey = null;\n\t\tfeature.setStyle(style);\n\t\t// Send event\n\t\tvar event = { type:'animationend', feature: feature };\n\t\tif (options) \n\t\t{\tfor (var i in options) if (options.hasOwnProperty(i))\n\t\t\t{ \tevent[i] = options[i]; \n\t\t\t}\n\t\t}\n\t\tfanim[step].dispatchEvent(event);\n\t\tself.dispatchEvent(event);\n\t}\n\n\t// Launch animation\n\tfunction start(options)\n\t{\tif (fanim.length && !listenerKey)\n\t\t{\tlistenerKey = self.on('postcompose', animate.bind(self));\n\t\t\t// map or layer?\n\t\t\tif (self.renderSync) self.renderSync();\n\t\t\telse self.changed();\n\t\t\t// Send event\n\t\t\tvar event = { type:'animationstart', feature: feature };\n\t\t\tif (options) \n\t\t\t{\tfor (var i in options) if (options.hasOwnProperty(i))\n\t\t\t\t{ \tevent[i] = options[i]; \n\t\t\t\t}\n\t\t\t}\n\t\t\tfanim[step].dispatchEvent(event);\n\t\t\tself.dispatchEvent(event);\n\t\t}\n\t}\n\tstart();\n\n\t// Return animation controler\n\treturn {\n\t\tstart: start,\n\t\tstop: stop,\n\t\tisPlaying: function() { return (!!listenerKey); }\n\t};\n};\n\nexport default ol_featureAnimation\n","/*\n\tCopyright (c) 2016-2018 Jean-Marc VIGLINO, \n\treleased under the CeCILL license (http://www.cecill.info/).\n\t\n*/\n\nimport {inherits as ol_inherits} from 'ol'\nimport ol_featureAnimation from './FeatureAnimation'\n\n/** Path animation: feature follow a path\n * @constructor\n * @extends {ol.featureAnimation}\n * @param {ol.featureAnimationPathOptions} options extend ol.featureAnimation options\n *  @param {Number} options.speed speed of the feature, if 0 the duration parameter will be used instead, default 0\n *  @param {Number|boolean} options.rotate rotate the symbol when following the path, true or the initial rotation, default false\n *  @param {ol.geom.LineString|ol.Feature} options.path the path to follow\n */\nvar ol_featureAnimation_Path = function(options)\n{\toptions = options || {};\n\tol_featureAnimation.call(this, options);\n\tthis.speed_ = options.speed || 0;\n\tthis.path_ = options.path;\n\tswitch (options.rotate) {\n\t\tcase true: \n\t\tcase 0:\n\t\t\tthis.rotate_ = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthis.rotate_ = options.rotate || false;\n\t\t\tbreak;\n\t}\n\tif (this.path_ && this.path_.getGeometry) this.path_ = this.path_.getGeometry();\n\tif (this.path_ && this.path_.getLineString) this.path_ = this.path_.getLineString();\n\tif (this.path_.getLength)\n\t{\tthis.dist_ = this.path_.getLength()\n\t\tif (this.path_ && this.path_.getCoordinates) this.path_ = this.path_.getCoordinates();\n\t}\n\telse this.dist_ = 0;\n\tif (this.speed_>0) this.duration_ = this.dist_/this.speed_;\n}\nol_inherits(ol_featureAnimation_Path, ol_featureAnimation);\n\n/** Animate\n* @param {ol_featureAnimationEvent} e\n*/\nol_featureAnimation_Path.prototype.animate = function (e)\n{\t// First time \n\tif (!e.time) \n\t{\tif (!this.dist_) return false;\n\t}\n\tvar dmax = this.dist_*this.easing_(e.elapsed);\n\tvar p0, p, s, dx,dy, dl, d = 0;\n\tp = this.path_[0];\n\t// Linear interpol\n\tfor (var i = 1; i<this.path_.length; i++)\n\t{\tp0 = p;\n\t\tp = this.path_[i];\n\t\tdx = p[0]-p0[0];\n\t\tdy = p[1]-p0[1];\n\t\tdl = Math.sqrt(dx*dx+dy*dy);\n\t\tif (dl && d+dl>=dmax) \n\t\t{\ts = (dmax-d)/dl;\n\t\t\tp = [ p0[0] + (p[0]-p0[0])*s, p0[1] + (p[1]-p0[1])*s];\n\t\t\tbreak;\n\t\t}\n\t\td += dl;\n\t}\n\t// Rotate symbols\n\tif (this.rotate_!==false) {\n\t\tvar angle = this.rotate_ - Math.atan2(p0[1] - p[1], p0[0] - p[0]);\n\t\tfor (var k=0; s=e.style[k]; k++) {\n\t\t\tif (s.getImage()) {\n\t\t\t\ts.getImage().setRotation(angle)\n\t\t\t}\n\t\t}\n\t}\n\te.geom.setCoordinates(p);\n\t// Animate\n\tthis.drawGeom_(e, e.geom);\n\t\n\treturn (e.time <= this.duration_);\n}\n\nexport default ol_featureAnimation_Path\n","<template>\r\n<div>\r\n  <div id=\"map\" :style=\"MapStyle\"></div>\r\n</div>\r\n</template>\r\n\r\n<script>\r\n// jquery\r\nimport $ from 'jquery';\r\n\r\n// 地图基础模块\r\nimport {Map, View} from 'ol';\r\nimport TileLayer from 'ol/layer/Tile';\r\nimport OSM from 'ol/source/OSM';\r\n\r\n// 地图控件\r\nimport {defaults as defaultControls,\r\n        MousePosition,\r\n        Control} from 'ol/control';\r\n\r\n// 扩展模块\r\nimport GPX from 'ol/format/GPX';\r\nimport VectorSource from 'ol/source/Vector';\r\nimport VectorLayer from 'ol/layer/Vector';\r\n\r\n// Style\r\nimport {Style, Stroke, Fill, RegularShape} from 'ol/style';\r\nimport Shadow from 'ol-ext/style/Shadow';\r\nimport Feature from 'ol/Feature';\r\nimport Point from 'ol/geom/Point';\r\nimport Path from 'ol-ext/featureanimation/Path';\r\nimport {linear, easwOut, easeIn, inAndOut, upAndDown} from 'ol/easing';\r\n\r\nexport default {\r\n  name: 'one-map',\r\n  data() {\r\n    return {\r\n      map: {},\r\n      view: {},\r\n      layers: [],\r\n      MapStyle: {\r\n        height: window.innerHeight + 'px',\r\n        width: '100%'\r\n      }\r\n    }\r\n  }, // data\r\n  methods: {\r\n    preDefine() {\r\n      // view\r\n      this.view = new View({\r\n        // center: [12175093.67465372, 4209022.808896985],\r\n        // zoom: 4.5,\r\n        zoom: 13,\r\n\t\t\t\tcenter: [646752, 5407059],\r\n        projection: 'EPSG:3857',\r\n      });\r\n      // layers\r\n      this.layers = [\r\n        new TileLayer({\r\n          source: new OSM(),\r\n          opacity: 0.7\r\n        })\r\n      ];\r\n    },\r\n    createMap() {\r\n      this.map = new Map({\r\n        controls: defaultControls({\r\n          attribution: false\r\n        }),\r\n        target: 'map',\r\n        view: this.view,\r\n        layers: this.layers,\r\n      });\r\n      \r\n      // 监听鼠标点击事件\r\n      this.map.on('click', event => {\r\n        console.log('点击坐标：(' + event.coordinate.toString() + ')');\r\n        console.log('地图缩放：' + event.map.getView().getZoom());\r\n      });\r\n    },\r\n    addGPXData() {\r\n      let style = [\r\n\r\n        // 1\r\n        new Style({\r\n          image: new Shadow({\r\n            radius: 15\r\n          }),\r\n          stroke: new Stroke({\r\n            color: [0,0,0,0.3],\r\n\t\t\t\t\t  width: 2\r\n\t\t\t\t  }),\r\n          fill: new Fill({\r\n            color: [0,0,0,0.3]\r\n          }),\r\n          zIndex: -1\r\n        }),\r\n        \r\n        // 2\r\n        new Style({\r\n          image: new RegularShape({\r\n            radius: 10,\r\n            radius2: 5,\r\n            points: 5,\r\n            fill: new Fill({ color: 'blue' })\r\n          }),\r\n          stroke: new Stroke({\r\n            color: [0,0,255],\r\n            width: 2\r\n          }),\r\n          fill: new Fill({\r\n            color: [0,0,255,0.3]\r\n          })\r\n        }),\r\n\r\n\r\n      ]; // style\r\n      style[1].getImage().getAnchor()[1] += 10;\r\n\r\n      let source = new VectorSource({\r\n        url: '/data/2009-09-04_rando.gpx',\r\n        format: new GPX()\r\n      });\r\n      console.log(source);\r\n      let vector = new VectorLayer({\r\n        source: source,\r\n        style: style\r\n      });\r\n      this.map.addLayer(vector);\r\n\r\n      // Animation\r\n      let path;\r\n      source.once('change', (e) => {\r\n        if (source.getState() === 'ready') {\r\n          path = source.getFeatures()[0];\r\n        }\r\n      });\r\n\r\n      // 在 map 上添加 feature\r\n      let animateFeature = () => {\r\n        if (path) {\r\n          let f = new Feature(new Point([0,0]));\r\n          let anim = new Path({\r\n            path: path,\r\n            rotate: true,\r\n            easing: linear, // linear, easeOut, easeIn, inAndOut\r\n            speed: Number(1.2), // min=\"0\" max=\"3\" step=\"0.1\"\r\n            revers: true\r\n          });\r\n          vector.animateFeature ( f, anim );\r\n        }\r\n      }\r\n\r\n      for (var i=0; i<4; i++) {\r\n        setTimeout( animateFeature, i*500 );\r\n      }\r\n    }\r\n  }, // methods\r\n  mounted() {\r\n    const self = this;\r\n    self.preDefine();  // 预定义地图要素\r\n    self.createMap();  // 创建地图\r\n\r\n    self.addGPXData();\r\n  }\r\n}\r\n</script>\r\n\r\n<style scoped>\r\n\r\n</style>","import mod from \"-!../../node_modules/_cache-loader@2.0.1@cache-loader/dist/cjs.js??ref--12-0!../../node_modules/_thread-loader@2.1.2@thread-loader/dist/cjs.js!../../node_modules/_babel-loader@8.0.5@babel-loader/lib/index.js!../../node_modules/_cache-loader@2.0.1@cache-loader/dist/cjs.js??ref--0-0!../../node_modules/_vue-loader@15.7.0@vue-loader/lib/index.js??vue-loader-options!./oneMap.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../node_modules/_cache-loader@2.0.1@cache-loader/dist/cjs.js??ref--12-0!../../node_modules/_thread-loader@2.1.2@thread-loader/dist/cjs.js!../../node_modules/_babel-loader@8.0.5@babel-loader/lib/index.js!../../node_modules/_cache-loader@2.0.1@cache-loader/dist/cjs.js??ref--0-0!../../node_modules/_vue-loader@15.7.0@vue-loader/lib/index.js??vue-loader-options!./oneMap.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./oneMap.vue?vue&type=template&id=35de42d0&scoped=true&\"\nimport script from \"./oneMap.vue?vue&type=script&lang=js&\"\nexport * from \"./oneMap.vue?vue&type=script&lang=js&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/_vue-loader@15.7.0@vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"35de42d0\",\n  null\n  \n)\n\nexport default component.exports","/**\n * @module ol/geom/flat/interpolate\n */\nimport {binarySearch} from '../../array.js';\nimport {lerp} from '../../math.js';\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} fraction Fraction.\n * @param {Array<number>=} opt_dest Destination.\n * @return {Array<number>} Destination.\n */\nexport function interpolatePoint(flatCoordinates, offset, end, stride, fraction, opt_dest) {\n  var pointX = NaN;\n  var pointY = NaN;\n  var n = (end - offset) / stride;\n  if (n === 1) {\n    pointX = flatCoordinates[offset];\n    pointY = flatCoordinates[offset + 1];\n  } else if (n == 2) {\n    pointX = (1 - fraction) * flatCoordinates[offset] +\n        fraction * flatCoordinates[offset + stride];\n    pointY = (1 - fraction) * flatCoordinates[offset + 1] +\n        fraction * flatCoordinates[offset + stride + 1];\n  } else if (n !== 0) {\n    var x1 = flatCoordinates[offset];\n    var y1 = flatCoordinates[offset + 1];\n    var length = 0;\n    var cumulativeLengths = [0];\n    for (var i = offset + stride; i < end; i += stride) {\n      var x2 = flatCoordinates[i];\n      var y2 = flatCoordinates[i + 1];\n      length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n      cumulativeLengths.push(length);\n      x1 = x2;\n      y1 = y2;\n    }\n    var target = fraction * length;\n    var index = binarySearch(cumulativeLengths, target);\n    if (index < 0) {\n      var t = (target - cumulativeLengths[-index - 2]) /\n          (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);\n      var o = offset + (-index - 2) * stride;\n      pointX = lerp(\n        flatCoordinates[o], flatCoordinates[o + stride], t);\n      pointY = lerp(\n        flatCoordinates[o + 1], flatCoordinates[o + stride + 1], t);\n    } else {\n      pointX = flatCoordinates[offset + index * stride];\n      pointY = flatCoordinates[offset + index * stride + 1];\n    }\n  }\n  if (opt_dest) {\n    opt_dest[0] = pointX;\n    opt_dest[1] = pointY;\n    return opt_dest;\n  } else {\n    return [pointX, pointY];\n  }\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} m M.\n * @param {boolean} extrapolate Extrapolate.\n * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\n */\nexport function lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, extrapolate) {\n  if (end == offset) {\n    return null;\n  }\n  var coordinate;\n  if (m < flatCoordinates[offset + stride - 1]) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(offset, offset + stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  } else if (flatCoordinates[end - 1] < m) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(end - stride, end);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  }\n  // FIXME use O(1) search\n  if (m == flatCoordinates[offset + stride - 1]) {\n    return flatCoordinates.slice(offset, offset + stride);\n  }\n  var lo = offset / stride;\n  var hi = end / stride;\n  while (lo < hi) {\n    var mid = (lo + hi) >> 1;\n    if (m < flatCoordinates[(mid + 1) * stride - 1]) {\n      hi = mid;\n    } else {\n      lo = mid + 1;\n    }\n  }\n  var m0 = flatCoordinates[lo * stride - 1];\n  if (m == m0) {\n    return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);\n  }\n  var m1 = flatCoordinates[(lo + 1) * stride - 1];\n  var t = (m - m0) / (m1 - m0);\n  coordinate = [];\n  for (var i = 0; i < stride - 1; ++i) {\n    coordinate.push(lerp(flatCoordinates[(lo - 1) * stride + i],\n      flatCoordinates[lo * stride + i], t));\n  }\n  coordinate.push(m);\n  return coordinate;\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} m M.\n * @param {boolean} extrapolate Extrapolate.\n * @param {boolean} interpolate Interpolate.\n * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\n */\nexport function lineStringsCoordinateAtM(\n  flatCoordinates, offset, ends, stride, m, extrapolate, interpolate) {\n  if (interpolate) {\n    return lineStringCoordinateAtM(\n      flatCoordinates, offset, ends[ends.length - 1], stride, m, extrapolate);\n  }\n  var coordinate;\n  if (m < flatCoordinates[stride - 1]) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(0, stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  }\n  if (flatCoordinates[flatCoordinates.length - 1] < m) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(flatCoordinates.length - stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  }\n  for (var i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    if (offset == end) {\n      continue;\n    }\n    if (m < flatCoordinates[offset + stride - 1]) {\n      return null;\n    } else if (m <= flatCoordinates[end - 1]) {\n      return lineStringCoordinateAtM(\n        flatCoordinates, offset, end, stride, m, false);\n    }\n    offset = end;\n  }\n  return null;\n}\n\n//# sourceMappingURL=interpolate.js.map","/**\n * @module ol/geom/LineString\n */\nimport {extend} from '../array.js';\nimport {closestSquaredDistanceXY} from '../extent.js';\nimport GeometryLayout from './GeometryLayout.js';\nimport GeometryType from './GeometryType.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {assignClosestPoint, maxSquaredDelta} from './flat/closest.js';\nimport {deflateCoordinates} from './flat/deflate.js';\nimport {inflateCoordinates} from './flat/inflate.js';\nimport {interpolatePoint, lineStringCoordinateAtM} from './flat/interpolate.js';\nimport {intersectsLineString} from './flat/intersectsextent.js';\nimport {lineStringLength} from './flat/length.js';\nimport {forEach as forEachSegment} from './flat/segments.js';\nimport {douglasPeucker} from './flat/simplify.js';\n\n/**\n * @classdesc\n * Linestring geometry.\n *\n * @api\n */\nvar LineString = /*@__PURE__*/(function (SimpleGeometry) {\n  function LineString(coordinates, opt_layout) {\n\n    SimpleGeometry.call(this);\n\n    /**\n     * @private\n     * @type {import(\"../coordinate.js\").Coordinate}\n     */\n    this.flatMidpoint_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.flatMidpointRevision_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDeltaRevision_ = -1;\n\n    if (opt_layout !== undefined && !Array.isArray(coordinates[0])) {\n      this.setFlatCoordinates(opt_layout, /** @type {Array<number>} */ (coordinates));\n    } else {\n      this.setCoordinates(/** @type {Array<import(\"../coordinate.js\").Coordinate>} */ (coordinates), opt_layout);\n    }\n\n  }\n\n  if ( SimpleGeometry ) LineString.__proto__ = SimpleGeometry;\n  LineString.prototype = Object.create( SimpleGeometry && SimpleGeometry.prototype );\n  LineString.prototype.constructor = LineString;\n\n  /**\n   * Append the passed coordinate to the coordinates of the linestring.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @api\n   */\n  LineString.prototype.appendCoordinate = function appendCoordinate (coordinate) {\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = coordinate.slice();\n    } else {\n      extend(this.flatCoordinates, coordinate);\n    }\n    this.changed();\n  };\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!LineString} Clone.\n   * @override\n   * @api\n   */\n  LineString.prototype.clone = function clone () {\n    return new LineString(this.flatCoordinates.slice(), this.layout);\n  };\n\n  /**\n   * @inheritDoc\n   */\n  LineString.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(maxSquaredDelta(\n        this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestPoint(\n      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,\n      this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);\n  };\n\n  /**\n   * Iterate over each segment, calling the provided callback.\n   * If the callback returns a truthy value the function returns that\n   * value immediately. Otherwise the function returns `false`.\n   *\n   * @param {function(this: S, import(\"../coordinate.js\").Coordinate, import(\"../coordinate.js\").Coordinate): T} callback Function\n   *     called for each segment.\n   * @return {T|boolean} Value.\n   * @template T,S\n   * @api\n   */\n  LineString.prototype.forEachSegment = function forEachSegment$1 (callback) {\n    return forEachSegment(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, callback);\n  };\n\n  /**\n   * Returns the coordinate at `m` using linear interpolation, or `null` if no\n   * such coordinate exists.\n   *\n   * `opt_extrapolate` controls extrapolation beyond the range of Ms in the\n   * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first\n   * M will return the first coordinate and Ms greater than the last M will\n   * return the last coordinate.\n   *\n   * @param {number} m M.\n   * @param {boolean=} opt_extrapolate Extrapolate. Default is `false`.\n   * @return {import(\"../coordinate.js\").Coordinate} Coordinate.\n   * @api\n   */\n  LineString.prototype.getCoordinateAtM = function getCoordinateAtM (m, opt_extrapolate) {\n    if (this.layout != GeometryLayout.XYM &&\n        this.layout != GeometryLayout.XYZM) {\n      return null;\n    }\n    var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;\n    return lineStringCoordinateAtM(this.flatCoordinates, 0,\n      this.flatCoordinates.length, this.stride, m, extrapolate);\n  };\n\n  /**\n   * Return the coordinates of the linestring.\n   * @return {Array<import(\"../coordinate.js\").Coordinate>} Coordinates.\n   * @override\n   * @api\n   */\n  LineString.prototype.getCoordinates = function getCoordinates () {\n    return inflateCoordinates(\n      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n  };\n\n  /**\n   * Return the coordinate at the provided fraction along the linestring.\n   * The `fraction` is a number between 0 and 1, where 0 is the start of the\n   * linestring and 1 is the end.\n   * @param {number} fraction Fraction.\n   * @param {import(\"../coordinate.js\").Coordinate=} opt_dest Optional coordinate whose values will\n   *     be modified. If not provided, a new coordinate will be returned.\n   * @return {import(\"../coordinate.js\").Coordinate} Coordinate of the interpolated point.\n   * @api\n   */\n  LineString.prototype.getCoordinateAt = function getCoordinateAt (fraction, opt_dest) {\n    return interpolatePoint(\n      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,\n      fraction, opt_dest);\n  };\n\n  /**\n   * Return the length of the linestring on projected plane.\n   * @return {number} Length (on projected plane).\n   * @api\n   */\n  LineString.prototype.getLength = function getLength () {\n    return lineStringLength(\n      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n  };\n\n  /**\n   * @return {Array<number>} Flat midpoint.\n   */\n  LineString.prototype.getFlatMidpoint = function getFlatMidpoint () {\n    if (this.flatMidpointRevision_ != this.getRevision()) {\n      this.flatMidpoint_ = this.getCoordinateAt(0.5, this.flatMidpoint_);\n      this.flatMidpointRevision_ = this.getRevision();\n    }\n    return this.flatMidpoint_;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  LineString.prototype.getSimplifiedGeometryInternal = function getSimplifiedGeometryInternal (squaredTolerance) {\n    var simplifiedFlatCoordinates = [];\n    simplifiedFlatCoordinates.length = douglasPeucker(\n      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,\n      squaredTolerance, simplifiedFlatCoordinates, 0);\n    return new LineString(simplifiedFlatCoordinates, GeometryLayout.XY);\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  LineString.prototype.getType = function getType () {\n    return GeometryType.LINE_STRING;\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  LineString.prototype.intersectsExtent = function intersectsExtent (extent) {\n    return intersectsLineString(\n      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,\n      extent);\n  };\n\n  /**\n   * Set the coordinates of the linestring.\n   * @param {!Array<import(\"../coordinate.js\").Coordinate>} coordinates Coordinates.\n   * @param {GeometryLayout=} opt_layout Layout.\n   * @override\n   * @api\n   */\n  LineString.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {\n    this.setLayout(opt_layout, coordinates, 1);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    this.flatCoordinates.length = deflateCoordinates(\n      this.flatCoordinates, 0, coordinates, this.stride);\n    this.changed();\n  };\n\n  return LineString;\n}(SimpleGeometry));\n\n\nexport default LineString;\n\n//# sourceMappingURL=LineString.js.map","/**\n * @module ol/geom/MultiLineString\n */\nimport {extend} from '../array.js';\nimport {closestSquaredDistanceXY} from '../extent.js';\nimport GeometryLayout from './GeometryLayout.js';\nimport GeometryType from './GeometryType.js';\nimport LineString from './LineString.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {assignClosestArrayPoint, arrayMaxSquaredDelta} from './flat/closest.js';\nimport {deflateCoordinatesArray} from './flat/deflate.js';\nimport {inflateCoordinatesArray} from './flat/inflate.js';\nimport {interpolatePoint, lineStringsCoordinateAtM} from './flat/interpolate.js';\nimport {intersectsLineStringArray} from './flat/intersectsextent.js';\nimport {douglasPeuckerArray} from './flat/simplify.js';\n\n/**\n * @classdesc\n * Multi-linestring geometry.\n *\n * @api\n */\nvar MultiLineString = /*@__PURE__*/(function (SimpleGeometry) {\n  function MultiLineString(coordinates, opt_layout, opt_ends) {\n\n    SimpleGeometry.call(this);\n\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n    this.ends_ = [];\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDeltaRevision_ = -1;\n\n    if (Array.isArray(coordinates[0])) {\n      this.setCoordinates(/** @type {Array<Array<import(\"../coordinate.js\").Coordinate>>} */ (coordinates), opt_layout);\n    } else if (opt_layout !== undefined && opt_ends) {\n      this.setFlatCoordinates(opt_layout, /** @type {Array<number>} */ (coordinates));\n      this.ends_ = opt_ends;\n    } else {\n      var layout = this.getLayout();\n      var lineStrings = /** @type {Array<LineString>} */ (coordinates);\n      var flatCoordinates = [];\n      var ends = [];\n      for (var i = 0, ii = lineStrings.length; i < ii; ++i) {\n        var lineString = lineStrings[i];\n        if (i === 0) {\n          layout = lineString.getLayout();\n        }\n        extend(flatCoordinates, lineString.getFlatCoordinates());\n        ends.push(flatCoordinates.length);\n      }\n      this.setFlatCoordinates(layout, flatCoordinates);\n      this.ends_ = ends;\n    }\n\n  }\n\n  if ( SimpleGeometry ) MultiLineString.__proto__ = SimpleGeometry;\n  MultiLineString.prototype = Object.create( SimpleGeometry && SimpleGeometry.prototype );\n  MultiLineString.prototype.constructor = MultiLineString;\n\n  /**\n   * Append the passed linestring to the multilinestring.\n   * @param {LineString} lineString LineString.\n   * @api\n   */\n  MultiLineString.prototype.appendLineString = function appendLineString (lineString) {\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = lineString.getFlatCoordinates().slice();\n    } else {\n      extend(this.flatCoordinates, lineString.getFlatCoordinates().slice());\n    }\n    this.ends_.push(this.flatCoordinates.length);\n    this.changed();\n  };\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!MultiLineString} Clone.\n   * @override\n   * @api\n   */\n  MultiLineString.prototype.clone = function clone () {\n    return new MultiLineString(this.flatCoordinates.slice(), this.layout, this.ends_.slice());\n  };\n\n  /**\n   * @inheritDoc\n   */\n  MultiLineString.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(arrayMaxSquaredDelta(\n        this.flatCoordinates, 0, this.ends_, this.stride, 0));\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestArrayPoint(\n      this.flatCoordinates, 0, this.ends_, this.stride,\n      this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);\n  };\n\n  /**\n   * Returns the coordinate at `m` using linear interpolation, or `null` if no\n   * such coordinate exists.\n   *\n   * `opt_extrapolate` controls extrapolation beyond the range of Ms in the\n   * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first\n   * M will return the first coordinate and Ms greater than the last M will\n   * return the last coordinate.\n   *\n   * `opt_interpolate` controls interpolation between consecutive LineStrings\n   * within the MultiLineString. If `opt_interpolate` is `true` the coordinates\n   * will be linearly interpolated between the last coordinate of one LineString\n   * and the first coordinate of the next LineString.  If `opt_interpolate` is\n   * `false` then the function will return `null` for Ms falling between\n   * LineStrings.\n   *\n   * @param {number} m M.\n   * @param {boolean=} opt_extrapolate Extrapolate. Default is `false`.\n   * @param {boolean=} opt_interpolate Interpolate. Default is `false`.\n   * @return {import(\"../coordinate.js\").Coordinate} Coordinate.\n   * @api\n   */\n  MultiLineString.prototype.getCoordinateAtM = function getCoordinateAtM (m, opt_extrapolate, opt_interpolate) {\n    if ((this.layout != GeometryLayout.XYM &&\n         this.layout != GeometryLayout.XYZM) ||\n        this.flatCoordinates.length === 0) {\n      return null;\n    }\n    var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;\n    var interpolate = opt_interpolate !== undefined ? opt_interpolate : false;\n    return lineStringsCoordinateAtM(this.flatCoordinates, 0,\n      this.ends_, this.stride, m, extrapolate, interpolate);\n  };\n\n  /**\n   * Return the coordinates of the multilinestring.\n   * @return {Array<Array<import(\"../coordinate.js\").Coordinate>>} Coordinates.\n   * @override\n   * @api\n   */\n  MultiLineString.prototype.getCoordinates = function getCoordinates () {\n    return inflateCoordinatesArray(\n      this.flatCoordinates, 0, this.ends_, this.stride);\n  };\n\n  /**\n   * @return {Array<number>} Ends.\n   */\n  MultiLineString.prototype.getEnds = function getEnds () {\n    return this.ends_;\n  };\n\n  /**\n   * Return the linestring at the specified index.\n   * @param {number} index Index.\n   * @return {LineString} LineString.\n   * @api\n   */\n  MultiLineString.prototype.getLineString = function getLineString (index) {\n    if (index < 0 || this.ends_.length <= index) {\n      return null;\n    }\n    return new LineString(this.flatCoordinates.slice(\n      index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);\n  };\n\n  /**\n   * Return the linestrings of this multilinestring.\n   * @return {Array<LineString>} LineStrings.\n   * @api\n   */\n  MultiLineString.prototype.getLineStrings = function getLineStrings () {\n    var flatCoordinates = this.flatCoordinates;\n    var ends = this.ends_;\n    var layout = this.layout;\n    /** @type {Array<LineString>} */\n    var lineStrings = [];\n    var offset = 0;\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n      var end = ends[i];\n      var lineString = new LineString(flatCoordinates.slice(offset, end), layout);\n      lineStrings.push(lineString);\n      offset = end;\n    }\n    return lineStrings;\n  };\n\n  /**\n   * @return {Array<number>} Flat midpoints.\n   */\n  MultiLineString.prototype.getFlatMidpoints = function getFlatMidpoints () {\n    var midpoints = [];\n    var flatCoordinates = this.flatCoordinates;\n    var offset = 0;\n    var ends = this.ends_;\n    var stride = this.stride;\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n      var end = ends[i];\n      var midpoint = interpolatePoint(\n        flatCoordinates, offset, end, stride, 0.5);\n      extend(midpoints, midpoint);\n      offset = end;\n    }\n    return midpoints;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  MultiLineString.prototype.getSimplifiedGeometryInternal = function getSimplifiedGeometryInternal (squaredTolerance) {\n    var simplifiedFlatCoordinates = [];\n    var simplifiedEnds = [];\n    simplifiedFlatCoordinates.length = douglasPeuckerArray(\n      this.flatCoordinates, 0, this.ends_, this.stride, squaredTolerance,\n      simplifiedFlatCoordinates, 0, simplifiedEnds);\n    return new MultiLineString(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEnds);\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  MultiLineString.prototype.getType = function getType () {\n    return GeometryType.MULTI_LINE_STRING;\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  MultiLineString.prototype.intersectsExtent = function intersectsExtent (extent) {\n    return intersectsLineStringArray(\n      this.flatCoordinates, 0, this.ends_, this.stride, extent);\n  };\n\n  /**\n   * Set the coordinates of the multilinestring.\n   * @param {!Array<Array<import(\"../coordinate.js\").Coordinate>>} coordinates Coordinates.\n   * @param {GeometryLayout=} opt_layout Layout.\n   * @override\n   * @api\n   */\n  MultiLineString.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {\n    this.setLayout(opt_layout, coordinates, 2);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    var ends = deflateCoordinatesArray(\n      this.flatCoordinates, 0, coordinates, this.stride, this.ends_);\n    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];\n    this.changed();\n  };\n\n  return MultiLineString;\n}(SimpleGeometry));\n\n\nexport default MultiLineString;\n\n//# sourceMappingURL=MultiLineString.js.map","/**\n * @module ol/xml\n */\nimport {extend} from './array.js';\n\n\n/**\n * When using {@link module:ol/xml~makeChildAppender} or\n * {@link module:ol/xml~makeSimpleNodeFactory}, the top `objectStack` item needs\n * to have this structure.\n * @typedef {Object} NodeStackItem\n * @property {Node} node\n */\n\n\n/**\n * @typedef {function(Element, Array<*>)} Parser\n */\n\n\n/**\n * @typedef {function(Element, *, Array<*>)} Serializer\n */\n\n\n/**\n * This document should be used when creating nodes for XML serializations. This\n * document is also used by {@link module:ol/xml~createElementNS}\n * @const\n * @type {Document}\n */\nexport var DOCUMENT = document.implementation.createDocument('', '', null);\n\n\n/**\n * @type {string}\n */\nexport var XML_SCHEMA_INSTANCE_URI = 'http://www.w3.org/2001/XMLSchema-instance';\n\n\n/**\n * @param {string} namespaceURI Namespace URI.\n * @param {string} qualifiedName Qualified name.\n * @return {Element} Node.\n */\nexport function createElementNS(namespaceURI, qualifiedName) {\n  return DOCUMENT.createElementNS(namespaceURI, qualifiedName);\n}\n\n\n/**\n * Recursively grab all text content of child nodes into a single string.\n * @param {Node} node Node.\n * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line\n * breaks.\n * @return {string} All text content.\n * @api\n */\nexport function getAllTextContent(node, normalizeWhitespace) {\n  return getAllTextContent_(node, normalizeWhitespace, []).join('');\n}\n\n\n/**\n * Recursively grab all text content of child nodes into a single string.\n * @param {Node} node Node.\n * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line\n * breaks.\n * @param {Array<string>} accumulator Accumulator.\n * @private\n * @return {Array<string>} Accumulator.\n */\nexport function getAllTextContent_(node, normalizeWhitespace, accumulator) {\n  if (node.nodeType == Node.CDATA_SECTION_NODE ||\n      node.nodeType == Node.TEXT_NODE) {\n    if (normalizeWhitespace) {\n      accumulator.push(String(node.nodeValue).replace(/(\\r\\n|\\r|\\n)/g, ''));\n    } else {\n      accumulator.push(node.nodeValue);\n    }\n  } else {\n    var n;\n    for (n = node.firstChild; n; n = n.nextSibling) {\n      getAllTextContent_(n, normalizeWhitespace, accumulator);\n    }\n  }\n  return accumulator;\n}\n\n\n/**\n * @param {Object} object Object.\n * @return {boolean} Is a document.\n */\nexport function isDocument(object) {\n  return 'documentElement' in object;\n}\n\n\n/**\n * @param {Element} node Node.\n * @param {?string} namespaceURI Namespace URI.\n * @param {string} name Attribute name.\n * @return {string} Value\n */\nexport function getAttributeNS(node, namespaceURI, name) {\n  return node.getAttributeNS(namespaceURI, name) || '';\n}\n\n\n/**\n * Parse an XML string to an XML Document.\n * @param {string} xml XML.\n * @return {Document} Document.\n * @api\n */\nexport function parse(xml) {\n  return new DOMParser().parseFromString(xml, 'application/xml');\n}\n\n\n/**\n * Make an array extender function for extending the array at the top of the\n * object stack.\n * @param {function(this: T, Node, Array<*>): (Array<*>|undefined)} valueReader Value reader.\n * @param {T=} opt_this The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeArrayExtender(valueReader, opt_this) {\n  return (\n    /**\n     * @param {Node} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function(node, objectStack) {\n      var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);\n      if (value !== undefined) {\n        var array = /** @type {Array<*>} */ (objectStack[objectStack.length - 1]);\n        extend(array, value);\n      }\n    }\n  );\n}\n\n\n/**\n * Make an array pusher function for pushing to the array at the top of the\n * object stack.\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\n * @param {T=} opt_this The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeArrayPusher(valueReader, opt_this) {\n  return (\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function(node, objectStack) {\n      var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);\n      if (value !== undefined) {\n        var array = /** @type {Array<*>} */ (objectStack[objectStack.length - 1]);\n        array.push(value);\n      }\n    });\n}\n\n\n/**\n * Make an object stack replacer function for replacing the object at the\n * top of the stack.\n * @param {function(this: T, Node, Array<*>): *} valueReader Value reader.\n * @param {T=} opt_this The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeReplacer(valueReader, opt_this) {\n  return (\n    /**\n     * @param {Node} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function(node, objectStack) {\n      var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);\n      if (value !== undefined) {\n        objectStack[objectStack.length - 1] = value;\n      }\n    });\n}\n\n\n/**\n * Make an object property pusher function for adding a property to the\n * object at the top of the stack.\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\n * @param {string=} opt_property Property.\n * @param {T=} opt_this The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeObjectPropertyPusher(valueReader, opt_property, opt_this) {\n  return (\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function(node, objectStack) {\n      var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);\n      if (value !== undefined) {\n        var object = /** @type {!Object} */ (objectStack[objectStack.length - 1]);\n        var property = opt_property !== undefined ? opt_property : node.localName;\n        var array;\n        if (property in object) {\n          array = object[property];\n        } else {\n          array = object[property] = [];\n        }\n        array.push(value);\n      }\n    });\n}\n\n\n/**\n * Make an object property setter function.\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\n * @param {string=} opt_property Property.\n * @param {T=} opt_this The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeObjectPropertySetter(valueReader, opt_property, opt_this) {\n  return (\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function(node, objectStack) {\n      var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);\n      if (value !== undefined) {\n        var object = /** @type {!Object} */ (objectStack[objectStack.length - 1]);\n        var property = opt_property !== undefined ? opt_property : node.localName;\n        object[property] = value;\n      }\n    });\n}\n\n\n/**\n * Create a serializer that appends nodes written by its `nodeWriter` to its\n * designated parent. The parent is the `node` of the\n * {@link module:ol/xml~NodeStackItem} at the top of the `objectStack`.\n * @param {function(this: T, Node, V, Array<*>)} nodeWriter Node writer.\n * @param {T=} opt_this The object to use as `this` in `nodeWriter`.\n * @return {Serializer} Serializer.\n * @template T, V\n */\nexport function makeChildAppender(nodeWriter, opt_this) {\n  return function(node, value, objectStack) {\n    nodeWriter.call(opt_this !== undefined ? opt_this : this, node, value, objectStack);\n    var parent = /** @type {NodeStackItem} */ (objectStack[objectStack.length - 1]);\n    var parentNode = parent.node;\n    parentNode.appendChild(node);\n  };\n}\n\n\n/**\n * Create a serializer that calls the provided `nodeWriter` from\n * {@link module:ol/xml~serialize}. This can be used by the parent writer to have the\n * 'nodeWriter' called with an array of values when the `nodeWriter` was\n * designed to serialize a single item. An example would be a LineString\n * geometry writer, which could be reused for writing MultiLineString\n * geometries.\n * @param {function(this: T, Element, V, Array<*>)} nodeWriter Node writer.\n * @param {T=} opt_this The object to use as `this` in `nodeWriter`.\n * @return {Serializer} Serializer.\n * @template T, V\n */\nexport function makeArraySerializer(nodeWriter, opt_this) {\n  var serializersNS, nodeFactory;\n  return function(node, value, objectStack) {\n    if (serializersNS === undefined) {\n      serializersNS = {};\n      var serializers = {};\n      serializers[node.localName] = nodeWriter;\n      serializersNS[node.namespaceURI] = serializers;\n      nodeFactory = makeSimpleNodeFactory(node.localName);\n    }\n    serialize(serializersNS, nodeFactory, value, objectStack);\n  };\n}\n\n\n/**\n * Create a node factory which can use the `opt_keys` passed to\n * {@link module:ol/xml~serialize} or {@link module:ol/xml~pushSerializeAndPop} as node names,\n * or a fixed node name. The namespace of the created nodes can either be fixed,\n * or the parent namespace will be used.\n * @param {string=} opt_nodeName Fixed node name which will be used for all\n *     created nodes. If not provided, the 3rd argument to the resulting node\n *     factory needs to be provided and will be the nodeName.\n * @param {string=} opt_namespaceURI Fixed namespace URI which will be used for\n *     all created nodes. If not provided, the namespace of the parent node will\n *     be used.\n * @return {function(*, Array<*>, string=): (Node|undefined)} Node factory.\n */\nexport function makeSimpleNodeFactory(opt_nodeName, opt_namespaceURI) {\n  var fixedNodeName = opt_nodeName;\n  return (\n    /**\n     * @param {*} value Value.\n     * @param {Array<*>} objectStack Object stack.\n     * @param {string=} opt_nodeName Node name.\n     * @return {Node} Node.\n     */\n    function(value, objectStack, opt_nodeName) {\n      var context = /** @type {NodeStackItem} */ (objectStack[objectStack.length - 1]);\n      var node = context.node;\n      var nodeName = fixedNodeName;\n      if (nodeName === undefined) {\n        nodeName = opt_nodeName;\n      }\n\n      var namespaceURI = opt_namespaceURI !== undefined ? opt_namespaceURI : node.namespaceURI;\n      return createElementNS(namespaceURI, /** @type {string} */ (nodeName));\n    }\n  );\n}\n\n\n/**\n * A node factory that creates a node using the parent's `namespaceURI` and the\n * `nodeName` passed by {@link module:ol/xml~serialize} or\n * {@link module:ol/xml~pushSerializeAndPop} to the node factory.\n * @const\n * @type {function(*, Array<*>, string=): (Node|undefined)}\n */\nexport var OBJECT_PROPERTY_NODE_FACTORY = makeSimpleNodeFactory();\n\n\n/**\n * Create an array of `values` to be used with {@link module:ol/xml~serialize} or\n * {@link module:ol/xml~pushSerializeAndPop}, where `orderedKeys` has to be provided as\n * `opt_key` argument.\n * @param {Object<string, V>} object Key-value pairs for the sequence. Keys can\n *     be a subset of the `orderedKeys`.\n * @param {Array<string>} orderedKeys Keys in the order of the sequence.\n * @return {Array<V>} Values in the order of the sequence. The resulting array\n *     has the same length as the `orderedKeys` array. Values that are not\n *     present in `object` will be `undefined` in the resulting array.\n * @template V\n */\nexport function makeSequence(object, orderedKeys) {\n  var length = orderedKeys.length;\n  var sequence = new Array(length);\n  for (var i = 0; i < length; ++i) {\n    sequence[i] = object[orderedKeys[i]];\n  }\n  return sequence;\n}\n\n\n/**\n * Create a namespaced structure, using the same values for each namespace.\n * This can be used as a starting point for versioned parsers, when only a few\n * values are version specific.\n * @param {Array<string>} namespaceURIs Namespace URIs.\n * @param {T} structure Structure.\n * @param {Object<string, T>=} opt_structureNS Namespaced structure to add to.\n * @return {Object<string, T>} Namespaced structure.\n * @template T\n */\nexport function makeStructureNS(namespaceURIs, structure, opt_structureNS) {\n  /**\n   * @type {Object<string, T>}\n   */\n  var structureNS = opt_structureNS !== undefined ? opt_structureNS : {};\n  var i, ii;\n  for (i = 0, ii = namespaceURIs.length; i < ii; ++i) {\n    structureNS[namespaceURIs[i]] = structure;\n  }\n  return structureNS;\n}\n\n\n/**\n * Parse a node using the parsers and object stack.\n * @param {Object<string, Object<string, Parser>>} parsersNS\n *     Parsers by namespace.\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @param {*=} opt_this The object to use as `this`.\n */\nexport function parseNode(parsersNS, node, objectStack, opt_this) {\n  var n;\n  for (n = node.firstElementChild; n; n = n.nextElementSibling) {\n    var parsers = parsersNS[n.namespaceURI];\n    if (parsers !== undefined) {\n      var parser = parsers[n.localName];\n      if (parser !== undefined) {\n        parser.call(opt_this, n, objectStack);\n      }\n    }\n  }\n}\n\n\n/**\n * Push an object on top of the stack, parse and return the popped object.\n * @param {T} object Object.\n * @param {Object<string, Object<string, Parser>>} parsersNS\n *     Parsers by namespace.\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @param {*=} opt_this The object to use as `this`.\n * @return {T} Object.\n * @template T\n */\nexport function pushParseAndPop(object, parsersNS, node, objectStack, opt_this) {\n  objectStack.push(object);\n  parseNode(parsersNS, node, objectStack, opt_this);\n  return /** @type {T} */ (objectStack.pop());\n}\n\n\n/**\n * Walk through an array of `values` and call a serializer for each value.\n * @param {Object<string, Object<string, Serializer>>} serializersNS\n *     Namespaced serializers.\n * @param {function(this: T, *, Array<*>, (string|undefined)): (Node|undefined)} nodeFactory\n *     Node factory. The `nodeFactory` creates the node whose namespace and name\n *     will be used to choose a node writer from `serializersNS`. This\n *     separation allows us to decide what kind of node to create, depending on\n *     the value we want to serialize. An example for this would be different\n *     geometry writers based on the geometry type.\n * @param {Array<*>} values Values to serialize. An example would be an array\n *     of {@link module:ol/Feature~Feature} instances.\n * @param {Array<*>} objectStack Node stack.\n * @param {Array<string>=} opt_keys Keys of the `values`. Will be passed to the\n *     `nodeFactory`. This is used for serializing object literals where the\n *     node name relates to the property key. The array length of `opt_keys` has\n *     to match the length of `values`. For serializing a sequence, `opt_keys`\n *     determines the order of the sequence.\n * @param {T=} opt_this The object to use as `this` for the node factory and\n *     serializers.\n * @template T\n */\nexport function serialize(\n  serializersNS, nodeFactory, values, objectStack, opt_keys, opt_this) {\n  var length = (opt_keys !== undefined ? opt_keys : values).length;\n  var value, node;\n  for (var i = 0; i < length; ++i) {\n    value = values[i];\n    if (value !== undefined) {\n      node = nodeFactory.call(opt_this !== undefined ? opt_this : this, value, objectStack,\n        opt_keys !== undefined ? opt_keys[i] : undefined);\n      if (node !== undefined) {\n        serializersNS[node.namespaceURI][node.localName]\n          .call(opt_this, node, value, objectStack);\n      }\n    }\n  }\n}\n\n\n/**\n * @param {O} object Object.\n * @param {Object<string, Object<string, Serializer>>} serializersNS\n *     Namespaced serializers.\n * @param {function(this: T, *, Array<*>, (string|undefined)): (Node|undefined)} nodeFactory\n *     Node factory. The `nodeFactory` creates the node whose namespace and name\n *     will be used to choose a node writer from `serializersNS`. This\n *     separation allows us to decide what kind of node to create, depending on\n *     the value we want to serialize. An example for this would be different\n *     geometry writers based on the geometry type.\n * @param {Array<*>} values Values to serialize. An example would be an array\n *     of {@link module:ol/Feature~Feature} instances.\n * @param {Array<*>} objectStack Node stack.\n * @param {Array<string>=} opt_keys Keys of the `values`. Will be passed to the\n *     `nodeFactory`. This is used for serializing object literals where the\n *     node name relates to the property key. The array length of `opt_keys` has\n *     to match the length of `values`. For serializing a sequence, `opt_keys`\n *     determines the order of the sequence.\n * @param {T=} opt_this The object to use as `this` for the node factory and\n *     serializers.\n * @return {O|undefined} Object.\n * @template O, T\n */\nexport function pushSerializeAndPop(object, serializersNS, nodeFactory, values, objectStack, opt_keys, opt_this) {\n  objectStack.push(object);\n  serialize(serializersNS, nodeFactory, values, objectStack, opt_keys, opt_this);\n  return /** @type {O|undefined} */ (objectStack.pop());\n}\n\n//# sourceMappingURL=xml.js.map"],"sourceRoot":""}