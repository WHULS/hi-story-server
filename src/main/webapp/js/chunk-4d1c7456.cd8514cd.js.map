{"version":3,"sources":["webpack:///./node_modules/_ol@5.3.1@ol/geom/Circle.js","webpack:///./node_modules/_ol@5.3.1@ol/geom/MultiPoint.js","webpack:///./node_modules/_ol@5.3.1@ol/geom/flat/center.js","webpack:///./node_modules/_ol@5.3.1@ol/geom/MultiPolygon.js","webpack:///./node_modules/_ol@5.3.1@ol/interaction/Draw.js","webpack:///./node_modules/_ol@5.3.1@ol/geom/flat/interpolate.js","webpack:///./node_modules/_ol@5.3.1@ol/geom/LineString.js","webpack:///./node_modules/_ol@5.3.1@ol/geom/MultiLineString.js"],"names":["Circle_Circle","SimpleGeometry","Circle","center","opt_radius","opt_layout","call","this","undefined","setFlatCoordinates","radius","setCenterAndRadius","__proto__","prototype","Object","create","constructor","clone","flatCoordinates","slice","layout","closestPointXY","x","y","closestPoint","minSquaredDistance","dx","dy","squaredDistance","i","stride","delta","getRadius","Math","sqrt","i$1","length","containsXY","getRadiusSquared_","getCenter","computeExtent","extent","_ol_5_3_1_ol_extent","getType","GeometryType","CIRCLE","intersectsExtent","circleExtent","getExtent","intersectsCoordinate","setCenter","changed","setLayout","offset","deflate","ii","getCoordinates","setCoordinates","coordinates","setRadius","geom_SimpleGeometry","transform","geom_Circle","MultiPoint_MultiPoint","MultiPoint","Array","isArray","appendPoint","point","array","getFlatCoordinates","multiPoint","math","j","inflate","getPoint","index","n","Point","getPoints","points","push","MULTI_POINT","geom_MultiPoint","linearRingss","endss","flatCenters","ends","MultiPolygon_MultiPolygon","MultiPolygon","opt_endss","endss_","flatInteriorPointsRevision_","flatInteriorPoints_","maxDelta_","maxDeltaRevision_","orientedRevision_","orientedFlatCoordinates_","getLayout","polygons","polygon","getEnds","jj","appendPolygon","len","newEndss","getRevision","closest","getOrientedFlatCoordinates","contains","getArea","flat_area","opt_right","orient","getEndss","getFlatInteriorPoints","interiorpoint","getInteriorPoints","GeometryLayout","XYM","getSimplifiedGeometryInternal","squaredTolerance","simplifiedFlatCoordinates","simplifiedEndss","simplify","XY","getPolygon","prevEnds","end","Polygon","getPolygons","MULTI_POLYGON","intersectsextent","lastEnds","geom_MultiPolygon","__webpack_require__","d","__webpack_exports__","createRegularPolygon","Mode","POINT","LINE_STRING","POLYGON","DrawEventType","DRAWSTART","DRAWEND","DrawEvent","Event","type","feature","Draw_Draw","PointerInteraction","Draw","options","pointerOptions","stopDown","functions","shouldHandle_","downPx_","downTimeout_","lastDragTime_","freehand_","source_","source","features_","features","snapTolerance_","snapTolerance","type_","mode_","getMode","stopClick_","stopClick","minPoints_","minPoints","maxPoints_","maxPoints","Infinity","finishCondition_","finishCondition","geometryFunction","opt_geometry","circle","NaN","squaredLength","_ol_5_3_1_ol_coordinate","Constructor","mode","LineString","geometry","concat","geometryFunction_","dragVertexDelay_","dragVertexDelay","finishCoordinate_","sketchFeature_","sketchPoint_","sketchCoords_","sketchLine_","sketchLineCoords_","squaredClickTolerance_","clickTolerance","overlay_","Vector","source_Vector","useSpatialIndex","wrapX","style","getDefaultStyleFunction","updateWhileInteracting","geometryName_","geometryName","condition_","condition","freehandCondition_","freehand","freehandCondition","events","_ol_5_3_1_ol_Object","Property","ACTIVE","updateState_","setMap","map","getOverlay","handleEvent","event","originalEvent","EventType","CONTEXTMENU","preventDefault","move","MapBrowserEventType","POINTERMOVE","pass","POINTERDRAG","now","Date","pixel","clearTimeout","addToDrawing_","POINTERDOWN","handlePointerMove_","pointerEvent","pointerType","MouseSource","DBLCLICK","handleDownEvent","startDrawing_","setTimeout","MapBrowserPointerEvent","frameState","bind","handleUpEvent","circleMode","finishDrawing","atFinish_","abortDrawing_","stopPropagation","downPx","clickPx","modifyDrawing_","createOrUpdateSketchPoint_","at","potentiallyDone","potentiallyFinishCoordinates","sketchCoords","finishCoordinate","finishPixel","getPixelFromCoordinate","coordinate","sketchPointGeom","getGeometry","Feature","updateSketchFeatures_","start","setGeometryName","setGeometry","dispatchEvent","last","sketchLineGeom","ring","getLinearRing","done","pop","removeLastPoint","splice","sketchFeature","MULTI_LINE_STRING","MultiLineString","addFeature","getSource","clear","extend","lineString","sketchFeatures","overlaySource","addFeatures","getMap","active","getActive","Pointer","styles","Style","resolution","opt_sides","opt_angle","angle","atan","PI","interpolatePoint","lineStringCoordinateAtM","lineStringsCoordinateAtM","_array_js__WEBPACK_IMPORTED_MODULE_0__","_math_js__WEBPACK_IMPORTED_MODULE_1__","fraction","opt_dest","pointX","pointY","x1","y1","cumulativeLengths","x2","y2","target","t","o","m","extrapolate","lo","hi","mid","m0","m1","interpolate","_extent_js__WEBPACK_IMPORTED_MODULE_1__","_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_2__","_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__","_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_4__","_flat_closest_js__WEBPACK_IMPORTED_MODULE_5__","_flat_deflate_js__WEBPACK_IMPORTED_MODULE_6__","_flat_inflate_js__WEBPACK_IMPORTED_MODULE_7__","_flat_interpolate_js__WEBPACK_IMPORTED_MODULE_8__","_flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_9__","_flat_length_js__WEBPACK_IMPORTED_MODULE_10__","_flat_segments_js__WEBPACK_IMPORTED_MODULE_11__","_flat_simplify_js__WEBPACK_IMPORTED_MODULE_12__","flatMidpoint_","flatMidpointRevision_","appendCoordinate","forEachSegment","callback","getCoordinateAtM","opt_extrapolate","XYZM","getCoordinateAt","getLength","getFlatMidpoint","_LineString_js__WEBPACK_IMPORTED_MODULE_4__","_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_5__","_flat_closest_js__WEBPACK_IMPORTED_MODULE_6__","_flat_deflate_js__WEBPACK_IMPORTED_MODULE_7__","_flat_inflate_js__WEBPACK_IMPORTED_MODULE_8__","_flat_interpolate_js__WEBPACK_IMPORTED_MODULE_9__","_flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_10__","_flat_simplify_js__WEBPACK_IMPORTED_MODULE_11__","opt_ends","ends_","lineStrings","appendLineString","opt_interpolate","getLineString","getLineStrings","getFlatMidpoints","midpoints","midpoint","simplifiedEnds"],"mappings":"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","file":"js/chunk-4d1c7456.cd8514cd.js","sourcesContent":["/**\n * @module ol/geom/Circle\n */\nimport {createOrUpdate, forEachCorner, intersects} from '../extent.js';\nimport GeometryType from './GeometryType.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {deflateCoordinate} from './flat/deflate.js';\n\n/**\n * @classdesc\n * Circle geometry.\n *\n * @api\n */\nvar Circle = /*@__PURE__*/(function (SimpleGeometry) {\n  function Circle(center, opt_radius, opt_layout) {\n    SimpleGeometry.call(this);\n    if (opt_layout !== undefined && opt_radius === undefined) {\n      this.setFlatCoordinates(opt_layout, center);\n    } else {\n      var radius = opt_radius ? opt_radius : 0;\n      this.setCenterAndRadius(center, radius, opt_layout);\n    }\n  }\n\n  if ( SimpleGeometry ) Circle.__proto__ = SimpleGeometry;\n  Circle.prototype = Object.create( SimpleGeometry && SimpleGeometry.prototype );\n  Circle.prototype.constructor = Circle;\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!Circle} Clone.\n   * @override\n   * @api\n   */\n  Circle.prototype.clone = function clone () {\n    return new Circle(this.flatCoordinates.slice(), undefined, this.layout);\n  };\n\n  /**\n   * @inheritDoc\n   */\n  Circle.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {\n    var flatCoordinates = this.flatCoordinates;\n    var dx = x - flatCoordinates[0];\n    var dy = y - flatCoordinates[1];\n    var squaredDistance = dx * dx + dy * dy;\n    if (squaredDistance < minSquaredDistance) {\n      if (squaredDistance === 0) {\n        for (var i = 0; i < this.stride; ++i) {\n          closestPoint[i] = flatCoordinates[i];\n        }\n      } else {\n        var delta = this.getRadius() / Math.sqrt(squaredDistance);\n        closestPoint[0] = flatCoordinates[0] + delta * dx;\n        closestPoint[1] = flatCoordinates[1] + delta * dy;\n        for (var i$1 = 2; i$1 < this.stride; ++i$1) {\n          closestPoint[i$1] = flatCoordinates[i$1];\n        }\n      }\n      closestPoint.length = this.stride;\n      return squaredDistance;\n    } else {\n      return minSquaredDistance;\n    }\n  };\n\n  /**\n   * @inheritDoc\n   */\n  Circle.prototype.containsXY = function containsXY (x, y) {\n    var flatCoordinates = this.flatCoordinates;\n    var dx = x - flatCoordinates[0];\n    var dy = y - flatCoordinates[1];\n    return dx * dx + dy * dy <= this.getRadiusSquared_();\n  };\n\n  /**\n   * Return the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.\n   * @return {import(\"../coordinate.js\").Coordinate} Center.\n   * @api\n   */\n  Circle.prototype.getCenter = function getCenter () {\n    return this.flatCoordinates.slice(0, this.stride);\n  };\n\n  /**\n   * @inheritDoc\n   */\n  Circle.prototype.computeExtent = function computeExtent (extent) {\n    var flatCoordinates = this.flatCoordinates;\n    var radius = flatCoordinates[this.stride] - flatCoordinates[0];\n    return createOrUpdate(\n      flatCoordinates[0] - radius, flatCoordinates[1] - radius,\n      flatCoordinates[0] + radius, flatCoordinates[1] + radius,\n      extent);\n  };\n\n  /**\n   * Return the radius of the circle.\n   * @return {number} Radius.\n   * @api\n   */\n  Circle.prototype.getRadius = function getRadius () {\n    return Math.sqrt(this.getRadiusSquared_());\n  };\n\n  /**\n   * @private\n   * @return {number} Radius squared.\n   */\n  Circle.prototype.getRadiusSquared_ = function getRadiusSquared_ () {\n    var dx = this.flatCoordinates[this.stride] - this.flatCoordinates[0];\n    var dy = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];\n    return dx * dx + dy * dy;\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  Circle.prototype.getType = function getType () {\n    return GeometryType.CIRCLE;\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  Circle.prototype.intersectsExtent = function intersectsExtent (extent) {\n    var circleExtent = this.getExtent();\n    if (intersects(extent, circleExtent)) {\n      var center = this.getCenter();\n\n      if (extent[0] <= center[0] && extent[2] >= center[0]) {\n        return true;\n      }\n      if (extent[1] <= center[1] && extent[3] >= center[1]) {\n        return true;\n      }\n\n      return forEachCorner(extent, this.intersectsCoordinate, this);\n    }\n    return false;\n\n  };\n\n  /**\n   * Set the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.\n   * @param {import(\"../coordinate.js\").Coordinate} center Center.\n   * @api\n   */\n  Circle.prototype.setCenter = function setCenter (center) {\n    var stride = this.stride;\n    var radius = this.flatCoordinates[stride] - this.flatCoordinates[0];\n    var flatCoordinates = center.slice();\n    flatCoordinates[stride] = flatCoordinates[0] + radius;\n    for (var i = 1; i < stride; ++i) {\n      flatCoordinates[stride + i] = center[i];\n    }\n    this.setFlatCoordinates(this.layout, flatCoordinates);\n    this.changed();\n  };\n\n  /**\n   * Set the center (as {@link module:ol/coordinate~Coordinate coordinate}) and the radius (as\n   * number) of the circle.\n   * @param {!import(\"../coordinate.js\").Coordinate} center Center.\n   * @param {number} radius Radius.\n   * @param {import(\"./GeometryLayout.js\").default=} opt_layout Layout.\n   * @api\n   */\n  Circle.prototype.setCenterAndRadius = function setCenterAndRadius (center, radius, opt_layout) {\n    this.setLayout(opt_layout, center, 0);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    /** @type {Array<number>} */\n    var flatCoordinates = this.flatCoordinates;\n    var offset = deflateCoordinate(\n      flatCoordinates, 0, center, this.stride);\n    flatCoordinates[offset++] = flatCoordinates[0] + radius;\n    for (var i = 1, ii = this.stride; i < ii; ++i) {\n      flatCoordinates[offset++] = flatCoordinates[i];\n    }\n    flatCoordinates.length = offset;\n    this.changed();\n  };\n\n  /**\n   * @inheritDoc\n   */\n  Circle.prototype.getCoordinates = function getCoordinates () {\n    return null;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  Circle.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {};\n\n  /**\n   * Set the radius of the circle. The radius is in the units of the projection.\n   * @param {number} radius Radius.\n   * @api\n   */\n  Circle.prototype.setRadius = function setRadius (radius) {\n    this.flatCoordinates[this.stride] = this.flatCoordinates[0] + radius;\n    this.changed();\n  };\n\n  return Circle;\n}(SimpleGeometry));\n\n\n/**\n * Transform each coordinate of the circle from one coordinate reference system\n * to another. The geometry is modified in place.\n * If you do not want the geometry modified in place, first clone() it and\n * then use this function on the clone.\n *\n * Internally a circle is currently represented by two points: the center of\n * the circle `[cx, cy]`, and the point to the right of the circle\n * `[cx + r, cy]`. This `transform` function just transforms these two points.\n * So the resulting geometry is also a circle, and that circle does not\n * correspond to the shape that would be obtained by transforming every point\n * of the original circle.\n *\n * @param {import(\"../proj.js\").ProjectionLike} source The current projection.  Can be a\n *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n * @param {import(\"../proj.js\").ProjectionLike} destination The desired projection.  Can be a\n *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n * @return {Circle} This geometry.  Note that original geometry is\n *     modified in place.\n * @function\n * @api\n */\nCircle.prototype.transform;\nexport default Circle;\n\n//# sourceMappingURL=Circle.js.map","/**\n * @module ol/geom/MultiPoint\n */\nimport {extend} from '../array.js';\nimport {closestSquaredDistanceXY, containsXY} from '../extent.js';\nimport GeometryType from './GeometryType.js';\nimport Point from './Point.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {deflateCoordinates} from './flat/deflate.js';\nimport {inflateCoordinates} from './flat/inflate.js';\nimport {squaredDistance as squaredDx} from '../math.js';\n\n/**\n * @classdesc\n * Multi-point geometry.\n *\n * @api\n */\nvar MultiPoint = /*@__PURE__*/(function (SimpleGeometry) {\n  function MultiPoint(coordinates, opt_layout) {\n    SimpleGeometry.call(this);\n    if (opt_layout && !Array.isArray(coordinates[0])) {\n      this.setFlatCoordinates(opt_layout, /** @type {Array<number>} */ (coordinates));\n    } else {\n      this.setCoordinates(/** @type {Array<import(\"../coordinate.js\").Coordinate>} */ (coordinates), opt_layout);\n    }\n  }\n\n  if ( SimpleGeometry ) MultiPoint.__proto__ = SimpleGeometry;\n  MultiPoint.prototype = Object.create( SimpleGeometry && SimpleGeometry.prototype );\n  MultiPoint.prototype.constructor = MultiPoint;\n\n  /**\n   * Append the passed point to this multipoint.\n   * @param {Point} point Point.\n   * @api\n   */\n  MultiPoint.prototype.appendPoint = function appendPoint (point) {\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = point.getFlatCoordinates().slice();\n    } else {\n      extend(this.flatCoordinates, point.getFlatCoordinates());\n    }\n    this.changed();\n  };\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!MultiPoint} Clone.\n   * @override\n   * @api\n   */\n  MultiPoint.prototype.clone = function clone () {\n    var multiPoint = new MultiPoint(this.flatCoordinates.slice(), this.layout);\n    return multiPoint;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  MultiPoint.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    var flatCoordinates = this.flatCoordinates;\n    var stride = this.stride;\n    for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n      var squaredDistance = squaredDx(\n        x, y, flatCoordinates[i], flatCoordinates[i + 1]);\n      if (squaredDistance < minSquaredDistance) {\n        minSquaredDistance = squaredDistance;\n        for (var j = 0; j < stride; ++j) {\n          closestPoint[j] = flatCoordinates[i + j];\n        }\n        closestPoint.length = stride;\n      }\n    }\n    return minSquaredDistance;\n  };\n\n  /**\n   * Return the coordinates of the multipoint.\n   * @return {Array<import(\"../coordinate.js\").Coordinate>} Coordinates.\n   * @override\n   * @api\n   */\n  MultiPoint.prototype.getCoordinates = function getCoordinates () {\n    return inflateCoordinates(\n      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n  };\n\n  /**\n   * Return the point at the specified index.\n   * @param {number} index Index.\n   * @return {Point} Point.\n   * @api\n   */\n  MultiPoint.prototype.getPoint = function getPoint (index) {\n    var n = !this.flatCoordinates ? 0 : this.flatCoordinates.length / this.stride;\n    if (index < 0 || n <= index) {\n      return null;\n    }\n    return new Point(this.flatCoordinates.slice(\n      index * this.stride, (index + 1) * this.stride), this.layout);\n  };\n\n  /**\n   * Return the points of this multipoint.\n   * @return {Array<Point>} Points.\n   * @api\n   */\n  MultiPoint.prototype.getPoints = function getPoints () {\n    var flatCoordinates = this.flatCoordinates;\n    var layout = this.layout;\n    var stride = this.stride;\n    /** @type {Array<Point>} */\n    var points = [];\n    for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n      var point = new Point(flatCoordinates.slice(i, i + stride), layout);\n      points.push(point);\n    }\n    return points;\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  MultiPoint.prototype.getType = function getType () {\n    return GeometryType.MULTI_POINT;\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  MultiPoint.prototype.intersectsExtent = function intersectsExtent (extent) {\n    var flatCoordinates = this.flatCoordinates;\n    var stride = this.stride;\n    for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n      var x = flatCoordinates[i];\n      var y = flatCoordinates[i + 1];\n      if (containsXY(extent, x, y)) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  /**\n   * Set the coordinates of the multipoint.\n   * @param {!Array<import(\"../coordinate.js\").Coordinate>} coordinates Coordinates.\n   * @param {import(\"./GeometryLayout.js\").default=} opt_layout Layout.\n   * @override\n   * @api\n   */\n  MultiPoint.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {\n    this.setLayout(opt_layout, coordinates, 1);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    this.flatCoordinates.length = deflateCoordinates(\n      this.flatCoordinates, 0, coordinates, this.stride);\n    this.changed();\n  };\n\n  return MultiPoint;\n}(SimpleGeometry));\n\n\nexport default MultiPoint;\n\n//# sourceMappingURL=MultiPoint.js.map","/**\n * @module ol/geom/flat/center\n */\nimport {createEmpty, createOrUpdateFromFlatCoordinates} from '../../extent.js';\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @return {Array<number>} Flat centers.\n */\nexport function linearRingss(flatCoordinates, offset, endss, stride) {\n  var flatCenters = [];\n  var extent = createEmpty();\n  for (var i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n    extent = createOrUpdateFromFlatCoordinates(flatCoordinates, offset, ends[0], stride);\n    flatCenters.push((extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2);\n    offset = ends[ends.length - 1];\n  }\n  return flatCenters;\n}\n\n//# sourceMappingURL=center.js.map","/**\n * @module ol/geom/MultiPolygon\n */\nimport {extend} from '../array.js';\nimport {closestSquaredDistanceXY} from '../extent.js';\nimport GeometryLayout from './GeometryLayout.js';\nimport GeometryType from './GeometryType.js';\nimport MultiPoint from './MultiPoint.js';\nimport Polygon from './Polygon.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {linearRingss as linearRingssArea} from './flat/area.js';\nimport {linearRingss as linearRingssCenter} from './flat/center.js';\nimport {assignClosestMultiArrayPoint, multiArrayMaxSquaredDelta} from './flat/closest.js';\nimport {linearRingssContainsXY} from './flat/contains.js';\nimport {deflateMultiCoordinatesArray} from './flat/deflate.js';\nimport {inflateMultiCoordinatesArray} from './flat/inflate.js';\nimport {getInteriorPointsOfMultiArray} from './flat/interiorpoint.js';\nimport {intersectsLinearRingMultiArray} from './flat/intersectsextent.js';\nimport {linearRingsAreOriented, orientLinearRingsArray} from './flat/orient.js';\nimport {quantizeMultiArray} from './flat/simplify.js';\n\n/**\n * @classdesc\n * Multi-polygon geometry.\n *\n * @api\n */\nvar MultiPolygon = /*@__PURE__*/(function (SimpleGeometry) {\n  function MultiPolygon(coordinates, opt_layout, opt_endss) {\n\n    SimpleGeometry.call(this);\n\n    /**\n     * @type {Array<Array<number>>}\n     * @private\n     */\n    this.endss_ = [];\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.flatInteriorPointsRevision_ = -1;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.flatInteriorPoints_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDeltaRevision_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.orientedRevision_ = -1;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.orientedFlatCoordinates_ = null;\n\n    if (!opt_endss && !Array.isArray(coordinates[0])) {\n      var layout = this.getLayout();\n      var polygons = /** @type {Array<Polygon>} */ (coordinates);\n      var flatCoordinates = [];\n      var endss = [];\n      for (var i = 0, ii = polygons.length; i < ii; ++i) {\n        var polygon = polygons[i];\n        if (i === 0) {\n          layout = polygon.getLayout();\n        }\n        var offset = flatCoordinates.length;\n        var ends = polygon.getEnds();\n        for (var j = 0, jj = ends.length; j < jj; ++j) {\n          ends[j] += offset;\n        }\n        extend(flatCoordinates, polygon.getFlatCoordinates());\n        endss.push(ends);\n      }\n      opt_layout = layout;\n      coordinates = flatCoordinates;\n      opt_endss = endss;\n    }\n    if (opt_layout !== undefined && opt_endss) {\n      this.setFlatCoordinates(opt_layout, /** @type {Array<number>} */ (coordinates));\n      this.endss_ = opt_endss;\n    } else {\n      this.setCoordinates(/** @type {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} */ (coordinates),\n        opt_layout);\n    }\n\n  }\n\n  if ( SimpleGeometry ) MultiPolygon.__proto__ = SimpleGeometry;\n  MultiPolygon.prototype = Object.create( SimpleGeometry && SimpleGeometry.prototype );\n  MultiPolygon.prototype.constructor = MultiPolygon;\n\n  /**\n   * Append the passed polygon to this multipolygon.\n   * @param {Polygon} polygon Polygon.\n   * @api\n   */\n  MultiPolygon.prototype.appendPolygon = function appendPolygon (polygon) {\n    /** @type {Array<number>} */\n    var ends;\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = polygon.getFlatCoordinates().slice();\n      ends = polygon.getEnds().slice();\n      this.endss_.push();\n    } else {\n      var offset = this.flatCoordinates.length;\n      extend(this.flatCoordinates, polygon.getFlatCoordinates());\n      ends = polygon.getEnds().slice();\n      for (var i = 0, ii = ends.length; i < ii; ++i) {\n        ends[i] += offset;\n      }\n    }\n    this.endss_.push(ends);\n    this.changed();\n  };\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!MultiPolygon} Clone.\n   * @override\n   * @api\n   */\n  MultiPolygon.prototype.clone = function clone () {\n    var len = this.endss_.length;\n    var newEndss = new Array(len);\n    for (var i = 0; i < len; ++i) {\n      newEndss[i] = this.endss_[i].slice();\n    }\n\n    return new MultiPolygon(\n      this.flatCoordinates.slice(), this.layout, newEndss);\n  };\n\n  /**\n   * @inheritDoc\n   */\n  MultiPolygon.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(multiArrayMaxSquaredDelta(\n        this.flatCoordinates, 0, this.endss_, this.stride, 0));\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestMultiArrayPoint(\n      this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride,\n      this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);\n  };\n\n  /**\n   * @inheritDoc\n   */\n  MultiPolygon.prototype.containsXY = function containsXY (x, y) {\n    return linearRingssContainsXY(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, x, y);\n  };\n\n  /**\n   * Return the area of the multipolygon on projected plane.\n   * @return {number} Area (on projected plane).\n   * @api\n   */\n  MultiPolygon.prototype.getArea = function getArea () {\n    return linearRingssArea(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride);\n  };\n\n  /**\n   * Get the coordinate array for this geometry.  This array has the structure\n   * of a GeoJSON coordinate array for multi-polygons.\n   *\n   * @param {boolean=} opt_right Orient coordinates according to the right-hand\n   *     rule (counter-clockwise for exterior and clockwise for interior rings).\n   *     If `false`, coordinates will be oriented according to the left-hand rule\n   *     (clockwise for exterior and counter-clockwise for interior rings).\n   *     By default, coordinate orientation will depend on how the geometry was\n   *     constructed.\n   * @return {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} Coordinates.\n   * @override\n   * @api\n   */\n  MultiPolygon.prototype.getCoordinates = function getCoordinates (opt_right) {\n    var flatCoordinates;\n    if (opt_right !== undefined) {\n      flatCoordinates = this.getOrientedFlatCoordinates().slice();\n      orientLinearRingsArray(\n        flatCoordinates, 0, this.endss_, this.stride, opt_right);\n    } else {\n      flatCoordinates = this.flatCoordinates;\n    }\n\n    return inflateMultiCoordinatesArray(\n      flatCoordinates, 0, this.endss_, this.stride);\n  };\n\n  /**\n   * @return {Array<Array<number>>} Endss.\n   */\n  MultiPolygon.prototype.getEndss = function getEndss () {\n    return this.endss_;\n  };\n\n  /**\n   * @return {Array<number>} Flat interior points.\n   */\n  MultiPolygon.prototype.getFlatInteriorPoints = function getFlatInteriorPoints () {\n    if (this.flatInteriorPointsRevision_ != this.getRevision()) {\n      var flatCenters = linearRingssCenter(\n        this.flatCoordinates, 0, this.endss_, this.stride);\n      this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(\n        this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride,\n        flatCenters);\n      this.flatInteriorPointsRevision_ = this.getRevision();\n    }\n    return this.flatInteriorPoints_;\n  };\n\n  /**\n   * Return the interior points as {@link module:ol/geom/MultiPoint multipoint}.\n   * @return {MultiPoint} Interior points as XYM coordinates, where M is\n   * the length of the horizontal intersection that the point belongs to.\n   * @api\n   */\n  MultiPolygon.prototype.getInteriorPoints = function getInteriorPoints () {\n    return new MultiPoint(this.getFlatInteriorPoints().slice(), GeometryLayout.XYM);\n  };\n\n  /**\n   * @return {Array<number>} Oriented flat coordinates.\n   */\n  MultiPolygon.prototype.getOrientedFlatCoordinates = function getOrientedFlatCoordinates () {\n    if (this.orientedRevision_ != this.getRevision()) {\n      var flatCoordinates = this.flatCoordinates;\n      if (linearRingsAreOriented(\n        flatCoordinates, 0, this.endss_, this.stride)) {\n        this.orientedFlatCoordinates_ = flatCoordinates;\n      } else {\n        this.orientedFlatCoordinates_ = flatCoordinates.slice();\n        this.orientedFlatCoordinates_.length =\n            orientLinearRingsArray(\n              this.orientedFlatCoordinates_, 0, this.endss_, this.stride);\n      }\n      this.orientedRevision_ = this.getRevision();\n    }\n    return this.orientedFlatCoordinates_;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  MultiPolygon.prototype.getSimplifiedGeometryInternal = function getSimplifiedGeometryInternal (squaredTolerance) {\n    var simplifiedFlatCoordinates = [];\n    var simplifiedEndss = [];\n    simplifiedFlatCoordinates.length = quantizeMultiArray(\n      this.flatCoordinates, 0, this.endss_, this.stride,\n      Math.sqrt(squaredTolerance),\n      simplifiedFlatCoordinates, 0, simplifiedEndss);\n    return new MultiPolygon(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEndss);\n  };\n\n  /**\n   * Return the polygon at the specified index.\n   * @param {number} index Index.\n   * @return {Polygon} Polygon.\n   * @api\n   */\n  MultiPolygon.prototype.getPolygon = function getPolygon (index) {\n    if (index < 0 || this.endss_.length <= index) {\n      return null;\n    }\n    var offset;\n    if (index === 0) {\n      offset = 0;\n    } else {\n      var prevEnds = this.endss_[index - 1];\n      offset = prevEnds[prevEnds.length - 1];\n    }\n    var ends = this.endss_[index].slice();\n    var end = ends[ends.length - 1];\n    if (offset !== 0) {\n      for (var i = 0, ii = ends.length; i < ii; ++i) {\n        ends[i] -= offset;\n      }\n    }\n    return new Polygon(this.flatCoordinates.slice(offset, end), this.layout, ends);\n  };\n\n  /**\n   * Return the polygons of this multipolygon.\n   * @return {Array<Polygon>} Polygons.\n   * @api\n   */\n  MultiPolygon.prototype.getPolygons = function getPolygons () {\n    var layout = this.layout;\n    var flatCoordinates = this.flatCoordinates;\n    var endss = this.endss_;\n    var polygons = [];\n    var offset = 0;\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n      var ends = endss[i].slice();\n      var end = ends[ends.length - 1];\n      if (offset !== 0) {\n        for (var j = 0, jj = ends.length; j < jj; ++j) {\n          ends[j] -= offset;\n        }\n      }\n      var polygon = new Polygon(flatCoordinates.slice(offset, end), layout, ends);\n      polygons.push(polygon);\n      offset = end;\n    }\n    return polygons;\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  MultiPolygon.prototype.getType = function getType () {\n    return GeometryType.MULTI_POLYGON;\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  MultiPolygon.prototype.intersectsExtent = function intersectsExtent (extent) {\n    return intersectsLinearRingMultiArray(\n      this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, extent);\n  };\n\n  /**\n   * Set the coordinates of the multipolygon.\n   * @param {!Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} coordinates Coordinates.\n   * @param {GeometryLayout=} opt_layout Layout.\n   * @override\n   * @api\n   */\n  MultiPolygon.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {\n    this.setLayout(opt_layout, coordinates, 3);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    var endss = deflateMultiCoordinatesArray(\n      this.flatCoordinates, 0, coordinates, this.stride, this.endss_);\n    if (endss.length === 0) {\n      this.flatCoordinates.length = 0;\n    } else {\n      var lastEnds = endss[endss.length - 1];\n      this.flatCoordinates.length = lastEnds.length === 0 ?\n        0 : lastEnds[lastEnds.length - 1];\n    }\n    this.changed();\n  };\n\n  return MultiPolygon;\n}(SimpleGeometry));\n\n\nexport default MultiPolygon;\n\n//# sourceMappingURL=MultiPolygon.js.map","/**\n * @module ol/interaction/Draw\n */\nimport EventType from '../events/EventType.js';\nimport Feature from '../Feature.js';\nimport MapBrowserEventType from '../MapBrowserEventType.js';\nimport MapBrowserPointerEvent from '../MapBrowserPointerEvent.js';\nimport {getChangeEventType} from '../Object.js';\nimport {squaredDistance as squaredCoordinateDistance} from '../coordinate.js';\nimport {listen} from '../events.js';\nimport Event from '../events/Event.js';\nimport {noModifierKeys, always, shiftKeyOnly} from '../events/condition.js';\nimport {boundingExtent, getBottomLeft, getBottomRight, getTopLeft, getTopRight} from '../extent.js';\nimport {TRUE, FALSE} from '../functions.js';\nimport Circle from '../geom/Circle.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport {POINTER_TYPE} from '../pointer/MouseSource.js';\nimport Point from '../geom/Point.js';\nimport Polygon, {fromCircle, makeRegular} from '../geom/Polygon.js';\nimport PointerInteraction from './Pointer.js';\nimport InteractionProperty from './Property.js';\nimport VectorLayer from '../layer/Vector.js';\nimport VectorSource from '../source/Vector.js';\nimport {createEditingStyle} from '../style/Style.js';\n\n\n/**\n * @typedef {Object} Options\n * @property {GeometryType} type Geometry type of\n * the geometries being drawn with this instance.\n * @property {number} [clickTolerance=6] The maximum distance in pixels between\n * \"down\" and \"up\" for a \"up\" event to be considered a \"click\" event and\n * actually add a point/vertex to the geometry being drawn.  The default of `6`\n * was chosen for the draw interaction to behave correctly on mouse as well as\n * on touch devices.\n * @property {import(\"../Collection.js\").default<Feature>} [features]\n * Destination collection for the drawn features.\n * @property {VectorSource} [source] Destination source for\n * the drawn features.\n * @property {number} [dragVertexDelay=500] Delay in milliseconds after pointerdown\n * before the current vertex can be dragged to its exact position.\n * @property {number} [snapTolerance=12] Pixel distance for snapping to the\n * drawing finish.\n * @property {boolean} [stopClick=false] Stop click, singleclick, and\n * doubleclick events from firing during drawing.\n * @property {number} [maxPoints] The number of points that can be drawn before\n * a polygon ring or line string is finished. By default there is no\n * restriction.\n * @property {number} [minPoints] The number of points that must be drawn\n * before a polygon ring or line string can be finished. Default is `3` for\n * polygon rings and `2` for line strings.\n * @property {import(\"../events/condition.js\").Condition} [finishCondition] A function\n * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether the drawing can be finished.\n * @property {import(\"../style/Style.js\").StyleLike} [style]\n * Style for sketch features.\n * @property {GeometryFunction} [geometryFunction]\n * Function that is called when a geometry's coordinates are updated.\n * @property {string} [geometryName] Geometry name to use for features created\n * by the draw interaction.\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled.\n * By default {@link module:ol/events/condition~noModifierKeys}, i.e. a click,\n * adds a vertex or deactivates freehand drawing.\n * @property {boolean} [freehand=false] Operate in freehand mode for lines,\n * polygons, and circles.  This makes the interaction always operate in freehand\n * mode and takes precedence over any `freehandCondition` option.\n * @property {import(\"../events/condition.js\").Condition} [freehandCondition]\n * Condition that activates freehand drawing for lines and polygons. This\n * function takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and\n * returns a boolean to indicate whether that event should be handled. The\n * default is {@link module:ol/events/condition~shiftKeyOnly}, meaning that the\n * Shift key activates freehand drawing.\n * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch\n * overlay.\n */\n\n\n/**\n * Coordinate type when drawing points.\n * @typedef {import(\"../coordinate.js\").Coordinate} PointCoordType\n */\n\n\n/**\n * Coordinate type when drawing lines.\n * @typedef {Array<import(\"../coordinate.js\").Coordinate>} LineCoordType\n */\n\n\n/**\n * Coordinate type when drawing polygons.\n * @typedef {Array<Array<import(\"../coordinate.js\").Coordinate>>} PolyCoordType\n */\n\n\n/**\n * Types used for drawing coordinates.\n * @typedef {PointCoordType|LineCoordType|PolyCoordType} SketchCoordType\n */\n\n\n/**\n * Function that takes an array of coordinates and an optional existing geometry as\n * arguments, and returns a geometry. The optional existing geometry is the\n * geometry that is returned when the function is called without a second\n * argument.\n * @typedef {function(!SketchCoordType, import(\"../geom/SimpleGeometry.js\").default=):\n *     import(\"../geom/SimpleGeometry.js\").default} GeometryFunction\n */\n\n\n/**\n * Draw mode.  This collapses multi-part geometry types with their single-part\n * cousins.\n * @enum {string}\n */\nvar Mode = {\n  POINT: 'Point',\n  LINE_STRING: 'LineString',\n  POLYGON: 'Polygon',\n  CIRCLE: 'Circle'\n};\n\n\n/**\n * @enum {string}\n */\nvar DrawEventType = {\n  /**\n   * Triggered upon feature draw start\n   * @event DrawEvent#drawstart\n   * @api\n   */\n  DRAWSTART: 'drawstart',\n  /**\n   * Triggered upon feature draw end\n   * @event DrawEvent#drawend\n   * @api\n   */\n  DRAWEND: 'drawend'\n};\n\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/Draw~Draw} instances are\n * instances of this type.\n */\nvar DrawEvent = /*@__PURE__*/(function (Event) {\n  function DrawEvent(type, feature) {\n\n    Event.call(this, type);\n\n    /**\n     * The feature being drawn.\n     * @type {Feature}\n     * @api\n     */\n    this.feature = feature;\n\n  }\n\n  if ( Event ) DrawEvent.__proto__ = Event;\n  DrawEvent.prototype = Object.create( Event && Event.prototype );\n  DrawEvent.prototype.constructor = DrawEvent;\n\n  return DrawEvent;\n}(Event));\n\n\n/**\n * @classdesc\n * Interaction for drawing feature geometries.\n *\n * @fires DrawEvent\n * @api\n */\nvar Draw = /*@__PURE__*/(function (PointerInteraction) {\n  function Draw(options) {\n\n    var pointerOptions = /** @type {import(\"./Pointer.js\").Options} */ (options);\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = FALSE;\n    }\n\n    PointerInteraction.call(this, pointerOptions);\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.shouldHandle_ = false;\n\n    /**\n     * @type {import(\"../pixel.js\").Pixel}\n     * @private\n     */\n    this.downPx_ = null;\n\n    /**\n     * @type {?}\n     * @private\n     */\n    this.downTimeout_;\n\n    /**\n     * @type {number|undefined}\n     * @private\n     */\n    this.lastDragTime_;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.freehand_ = false;\n\n    /**\n     * Target source for drawn features.\n     * @type {VectorSource}\n     * @private\n     */\n    this.source_ = options.source ? options.source : null;\n\n    /**\n     * Target collection for drawn features.\n     * @type {import(\"../Collection.js\").default<Feature>}\n     * @private\n     */\n    this.features_ = options.features ? options.features : null;\n\n    /**\n     * Pixel distance for snapping.\n     * @type {number}\n     * @private\n     */\n    this.snapTolerance_ = options.snapTolerance ? options.snapTolerance : 12;\n\n    /**\n     * Geometry type.\n     * @type {GeometryType}\n     * @private\n     */\n    this.type_ = /** @type {GeometryType} */ (options.type);\n\n    /**\n     * Drawing mode (derived from geometry type.\n     * @type {Mode}\n     * @private\n     */\n    this.mode_ = getMode(this.type_);\n\n    /**\n     * Stop click, singleclick, and doubleclick events from firing during drawing.\n     * Default is `false`.\n     * @type {boolean}\n     * @private\n     */\n    this.stopClick_ = !!options.stopClick;\n\n    /**\n     * The number of points that must be drawn before a polygon ring or line\n     * string can be finished.  The default is 3 for polygon rings and 2 for\n     * line strings.\n     * @type {number}\n     * @private\n     */\n    this.minPoints_ = options.minPoints ?\n      options.minPoints :\n      (this.mode_ === Mode.POLYGON ? 3 : 2);\n\n    /**\n     * The number of points that can be drawn before a polygon ring or line string\n     * is finished. The default is no restriction.\n     * @type {number}\n     * @private\n     */\n    this.maxPoints_ = options.maxPoints ? options.maxPoints : Infinity;\n\n    /**\n     * A function to decide if a potential finish coordinate is permissible\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.finishCondition_ = options.finishCondition ? options.finishCondition : TRUE;\n\n    var geometryFunction = options.geometryFunction;\n    if (!geometryFunction) {\n      if (this.type_ === GeometryType.CIRCLE) {\n        /**\n         * @param {!LineCoordType} coordinates The coordinates.\n         * @param {import(\"../geom/SimpleGeometry.js\").default=} opt_geometry Optional geometry.\n         * @return {import(\"../geom/SimpleGeometry.js\").default} A geometry.\n         */\n        geometryFunction = function(coordinates, opt_geometry) {\n          var circle = opt_geometry ? /** @type {Circle} */ (opt_geometry) :\n            new Circle([NaN, NaN]);\n          var squaredLength = squaredCoordinateDistance(\n            coordinates[0], coordinates[1]);\n          circle.setCenterAndRadius(coordinates[0], Math.sqrt(squaredLength));\n          return circle;\n        };\n      } else {\n        var Constructor;\n        var mode = this.mode_;\n        if (mode === Mode.POINT) {\n          Constructor = Point;\n        } else if (mode === Mode.LINE_STRING) {\n          Constructor = LineString;\n        } else if (mode === Mode.POLYGON) {\n          Constructor = Polygon;\n        }\n        /**\n         * @param {!LineCoordType} coordinates The coordinates.\n         * @param {import(\"../geom/SimpleGeometry.js\").default=} opt_geometry Optional geometry.\n         * @return {import(\"../geom/SimpleGeometry.js\").default} A geometry.\n         */\n        geometryFunction = function(coordinates, opt_geometry) {\n          var geometry = opt_geometry;\n          if (geometry) {\n            if (mode === Mode.POLYGON) {\n              if (coordinates[0].length) {\n                // Add a closing coordinate to match the first\n                geometry.setCoordinates([coordinates[0].concat([coordinates[0][0]])]);\n              } else {\n                geometry.setCoordinates([]);\n              }\n            } else {\n              geometry.setCoordinates(coordinates);\n            }\n          } else {\n            geometry = new Constructor(coordinates);\n          }\n          return geometry;\n        };\n      }\n    }\n\n    /**\n     * @type {GeometryFunction}\n     * @private\n     */\n    this.geometryFunction_ = geometryFunction;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.dragVertexDelay_ = options.dragVertexDelay !== undefined ? options.dragVertexDelay : 500;\n\n    /**\n     * Finish coordinate for the feature (first point for polygons, last point for\n     * linestrings).\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    this.finishCoordinate_ = null;\n\n    /**\n     * Sketch feature.\n     * @type {Feature}\n     * @private\n     */\n    this.sketchFeature_ = null;\n\n    /**\n     * Sketch point.\n     * @type {Feature}\n     * @private\n     */\n    this.sketchPoint_ = null;\n\n    /**\n     * Sketch coordinates. Used when drawing a line or polygon.\n     * @type {SketchCoordType}\n     * @private\n     */\n    this.sketchCoords_ = null;\n\n    /**\n     * Sketch line. Used when drawing polygon.\n     * @type {Feature}\n     * @private\n     */\n    this.sketchLine_ = null;\n\n    /**\n     * Sketch line coordinates. Used when drawing a polygon or circle.\n     * @type {LineCoordType}\n     * @private\n     */\n    this.sketchLineCoords_ = null;\n\n    /**\n     * Squared tolerance for handling up events.  If the squared distance\n     * between a down and up event is greater than this tolerance, up events\n     * will not be handled.\n     * @type {number}\n     * @private\n     */\n    this.squaredClickTolerance_ = options.clickTolerance ?\n      options.clickTolerance * options.clickTolerance : 36;\n\n    /**\n     * Draw overlay where our sketch features are drawn.\n     * @type {VectorLayer}\n     * @private\n     */\n    this.overlay_ = new VectorLayer({\n      source: new VectorSource({\n        useSpatialIndex: false,\n        wrapX: options.wrapX ? options.wrapX : false\n      }),\n      style: options.style ? options.style :\n        getDefaultStyleFunction(),\n      updateWhileInteracting: true\n    });\n\n    /**\n     * Name of the geometry attribute for newly created features.\n     * @type {string|undefined}\n     * @private\n     */\n    this.geometryName_ = options.geometryName;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.condition_ = options.condition ? options.condition : noModifierKeys;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.freehandCondition_;\n    if (options.freehand) {\n      this.freehandCondition_ = always;\n    } else {\n      this.freehandCondition_ = options.freehandCondition ?\n        options.freehandCondition : shiftKeyOnly;\n    }\n\n    listen(this,\n      getChangeEventType(InteractionProperty.ACTIVE),\n      this.updateState_, this);\n\n  }\n\n  if ( PointerInteraction ) Draw.__proto__ = PointerInteraction;\n  Draw.prototype = Object.create( PointerInteraction && PointerInteraction.prototype );\n  Draw.prototype.constructor = Draw;\n\n  /**\n   * @inheritDoc\n   */\n  Draw.prototype.setMap = function setMap (map) {\n    PointerInteraction.prototype.setMap.call(this, map);\n    this.updateState_();\n  };\n\n  /**\n   * Get the overlay layer that this interaction renders sketch features to.\n   * @return {VectorLayer} Overlay layer.\n   * @api\n   */\n  Draw.prototype.getOverlay = function getOverlay () {\n    return this.overlay_;\n  };\n\n  /**\n   * Handles the {@link module:ol/MapBrowserEvent map browser event} and may actually draw or finish the drawing.\n   * @override\n   * @api\n   */\n  Draw.prototype.handleEvent = function handleEvent (event) {\n    if (event.originalEvent.type === EventType.CONTEXTMENU) {\n      // Avoid context menu for long taps when drawing on mobile\n      event.preventDefault();\n    }\n    this.freehand_ = this.mode_ !== Mode.POINT && this.freehandCondition_(event);\n    var move = event.type === MapBrowserEventType.POINTERMOVE;\n    var pass = true;\n    if (!this.freehand_ && this.lastDragTime_ && event.type === MapBrowserEventType.POINTERDRAG) {\n      var now = Date.now();\n      if (now - this.lastDragTime_ >= this.dragVertexDelay_) {\n        this.downPx_ = event.pixel;\n        this.shouldHandle_ = !this.freehand_;\n        move = true;\n      } else {\n        this.lastDragTime_ = undefined;\n      }\n      if (this.shouldHandle_ && this.downTimeout_ !== undefined) {\n        clearTimeout(this.downTimeout_);\n        this.downTimeout_ = undefined;\n      }\n    }\n    if (this.freehand_ &&\n        event.type === MapBrowserEventType.POINTERDRAG &&\n        this.sketchFeature_ !== null) {\n      this.addToDrawing_(event);\n      pass = false;\n    } else if (this.freehand_ &&\n        event.type === MapBrowserEventType.POINTERDOWN) {\n      pass = false;\n    } else if (move) {\n      pass = event.type === MapBrowserEventType.POINTERMOVE;\n      if (pass && this.freehand_) {\n        pass = this.handlePointerMove_(event);\n      } else if (/** @type {MapBrowserPointerEvent} */ (event).pointerEvent.pointerType == POINTER_TYPE ||\n          (event.type === MapBrowserEventType.POINTERDRAG && this.downTimeout_ === undefined)) {\n        this.handlePointerMove_(event);\n      }\n    } else if (event.type === MapBrowserEventType.DBLCLICK) {\n      pass = false;\n    }\n\n    return PointerInteraction.prototype.handleEvent.call(this, event) && pass;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  Draw.prototype.handleDownEvent = function handleDownEvent (event) {\n    this.shouldHandle_ = !this.freehand_;\n\n    if (this.freehand_) {\n      this.downPx_ = event.pixel;\n      if (!this.finishCoordinate_) {\n        this.startDrawing_(event);\n      }\n      return true;\n    } else if (this.condition_(event)) {\n      this.lastDragTime_ = Date.now();\n      this.downTimeout_ = setTimeout(function() {\n        this.handlePointerMove_(new MapBrowserPointerEvent(\n          MapBrowserEventType.POINTERMOVE, event.map, event.pointerEvent, false, event.frameState));\n      }.bind(this), this.dragVertexDelay_);\n      this.downPx_ = event.pixel;\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n\n  /**\n   * @inheritDoc\n   */\n  Draw.prototype.handleUpEvent = function handleUpEvent (event) {\n    var pass = true;\n\n    if (this.downTimeout_) {\n      clearTimeout(this.downTimeout_);\n      this.downTimeout_ = undefined;\n    }\n\n    this.handlePointerMove_(event);\n\n    var circleMode = this.mode_ === Mode.CIRCLE;\n\n    if (this.shouldHandle_) {\n      if (!this.finishCoordinate_) {\n        this.startDrawing_(event);\n        if (this.mode_ === Mode.POINT) {\n          this.finishDrawing();\n        }\n      } else if (this.freehand_ || circleMode) {\n        this.finishDrawing();\n      } else if (this.atFinish_(event)) {\n        if (this.finishCondition_(event)) {\n          this.finishDrawing();\n        }\n      } else {\n        this.addToDrawing_(event);\n      }\n      pass = false;\n    } else if (this.freehand_) {\n      this.finishCoordinate_ = null;\n      this.abortDrawing_();\n    }\n    if (!pass && this.stopClick_) {\n      event.stopPropagation();\n    }\n    return pass;\n  };\n\n  /**\n   * Handle move events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event A move event.\n   * @return {boolean} Pass the event to other interactions.\n   * @private\n   */\n  Draw.prototype.handlePointerMove_ = function handlePointerMove_ (event) {\n    if (this.downPx_ &&\n        ((!this.freehand_ && this.shouldHandle_) ||\n        (this.freehand_ && !this.shouldHandle_))) {\n      var downPx = this.downPx_;\n      var clickPx = event.pixel;\n      var dx = downPx[0] - clickPx[0];\n      var dy = downPx[1] - clickPx[1];\n      var squaredDistance = dx * dx + dy * dy;\n      this.shouldHandle_ = this.freehand_ ?\n        squaredDistance > this.squaredClickTolerance_ :\n        squaredDistance <= this.squaredClickTolerance_;\n      if (!this.shouldHandle_) {\n        return true;\n      }\n    }\n\n    if (this.finishCoordinate_) {\n      this.modifyDrawing_(event);\n    } else {\n      this.createOrUpdateSketchPoint_(event);\n    }\n    return true;\n  };\n\n  /**\n   * Determine if an event is within the snapping tolerance of the start coord.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @return {boolean} The event is within the snapping tolerance of the start.\n   * @private\n   */\n  Draw.prototype.atFinish_ = function atFinish_ (event) {\n    var at = false;\n    if (this.sketchFeature_) {\n      var potentiallyDone = false;\n      var potentiallyFinishCoordinates = [this.finishCoordinate_];\n      if (this.mode_ === Mode.LINE_STRING) {\n        potentiallyDone = this.sketchCoords_.length > this.minPoints_;\n      } else if (this.mode_ === Mode.POLYGON) {\n        var sketchCoords = /** @type {PolyCoordType} */ (this.sketchCoords_);\n        potentiallyDone = sketchCoords[0].length > this.minPoints_;\n        potentiallyFinishCoordinates = [sketchCoords[0][0], sketchCoords[0][sketchCoords[0].length - 2]];\n      }\n      if (potentiallyDone) {\n        var map = event.map;\n        for (var i = 0, ii = potentiallyFinishCoordinates.length; i < ii; i++) {\n          var finishCoordinate = potentiallyFinishCoordinates[i];\n          var finishPixel = map.getPixelFromCoordinate(finishCoordinate);\n          var pixel = event.pixel;\n          var dx = pixel[0] - finishPixel[0];\n          var dy = pixel[1] - finishPixel[1];\n          var snapTolerance = this.freehand_ ? 1 : this.snapTolerance_;\n          at = Math.sqrt(dx * dx + dy * dy) <= snapTolerance;\n          if (at) {\n            this.finishCoordinate_ = finishCoordinate;\n            break;\n          }\n        }\n      }\n    }\n    return at;\n  };\n\n  /**\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @private\n   */\n  Draw.prototype.createOrUpdateSketchPoint_ = function createOrUpdateSketchPoint_ (event) {\n    var coordinates = event.coordinate.slice();\n    if (!this.sketchPoint_) {\n      this.sketchPoint_ = new Feature(new Point(coordinates));\n      this.updateSketchFeatures_();\n    } else {\n      var sketchPointGeom = /** @type {Point} */ (this.sketchPoint_.getGeometry());\n      sketchPointGeom.setCoordinates(coordinates);\n    }\n  };\n\n  /**\n   * Start the drawing.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @private\n   */\n  Draw.prototype.startDrawing_ = function startDrawing_ (event) {\n    var start = event.coordinate;\n    this.finishCoordinate_ = start;\n    if (this.mode_ === Mode.POINT) {\n      this.sketchCoords_ = start.slice();\n    } else if (this.mode_ === Mode.POLYGON) {\n      this.sketchCoords_ = [[start.slice(), start.slice()]];\n      this.sketchLineCoords_ = this.sketchCoords_[0];\n    } else {\n      this.sketchCoords_ = [start.slice(), start.slice()];\n    }\n    if (this.sketchLineCoords_) {\n      this.sketchLine_ = new Feature(\n        new LineString(this.sketchLineCoords_));\n    }\n    var geometry = this.geometryFunction_(this.sketchCoords_);\n    this.sketchFeature_ = new Feature();\n    if (this.geometryName_) {\n      this.sketchFeature_.setGeometryName(this.geometryName_);\n    }\n    this.sketchFeature_.setGeometry(geometry);\n    this.updateSketchFeatures_();\n    this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));\n  };\n\n  /**\n   * Modify the drawing.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @private\n   */\n  Draw.prototype.modifyDrawing_ = function modifyDrawing_ (event) {\n    var coordinate = event.coordinate;\n    var geometry = /** @type {import(\"../geom/SimpleGeometry.js\").default} */ (this.sketchFeature_.getGeometry());\n    var coordinates, last;\n    if (this.mode_ === Mode.POINT) {\n      last = this.sketchCoords_;\n    } else if (this.mode_ === Mode.POLYGON) {\n      coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];\n      last = coordinates[coordinates.length - 1];\n      if (this.atFinish_(event)) {\n        // snap to finish\n        coordinate = this.finishCoordinate_.slice();\n      }\n    } else {\n      coordinates = this.sketchCoords_;\n      last = coordinates[coordinates.length - 1];\n    }\n    last[0] = coordinate[0];\n    last[1] = coordinate[1];\n    this.geometryFunction_(/** @type {!LineCoordType} */ (this.sketchCoords_), geometry);\n    if (this.sketchPoint_) {\n      var sketchPointGeom = /** @type {Point} */ (this.sketchPoint_.getGeometry());\n      sketchPointGeom.setCoordinates(coordinate);\n    }\n    /** @type {LineString} */\n    var sketchLineGeom;\n    if (geometry.getType() == GeometryType.POLYGON &&\n        this.mode_ !== Mode.POLYGON) {\n      if (!this.sketchLine_) {\n        this.sketchLine_ = new Feature();\n      }\n      var ring = /** @type {Polygon} */ (geometry).getLinearRing(0);\n      sketchLineGeom = /** @type {LineString} */ (this.sketchLine_.getGeometry());\n      if (!sketchLineGeom) {\n        sketchLineGeom = new LineString(ring.getFlatCoordinates(), ring.getLayout());\n        this.sketchLine_.setGeometry(sketchLineGeom);\n      } else {\n        sketchLineGeom.setFlatCoordinates(\n          ring.getLayout(), ring.getFlatCoordinates());\n        sketchLineGeom.changed();\n      }\n    } else if (this.sketchLineCoords_) {\n      sketchLineGeom = /** @type {LineString} */ (this.sketchLine_.getGeometry());\n      sketchLineGeom.setCoordinates(this.sketchLineCoords_);\n    }\n    this.updateSketchFeatures_();\n  };\n\n  /**\n   * Add a new coordinate to the drawing.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @private\n   */\n  Draw.prototype.addToDrawing_ = function addToDrawing_ (event) {\n    var coordinate = event.coordinate;\n    var geometry = /** @type {import(\"../geom/SimpleGeometry.js\").default} */ (this.sketchFeature_.getGeometry());\n    var done;\n    var coordinates;\n    if (this.mode_ === Mode.LINE_STRING) {\n      this.finishCoordinate_ = coordinate.slice();\n      coordinates = /** @type {LineCoordType} */ (this.sketchCoords_);\n      if (coordinates.length >= this.maxPoints_) {\n        if (this.freehand_) {\n          coordinates.pop();\n        } else {\n          done = true;\n        }\n      }\n      coordinates.push(coordinate.slice());\n      this.geometryFunction_(coordinates, geometry);\n    } else if (this.mode_ === Mode.POLYGON) {\n      coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];\n      if (coordinates.length >= this.maxPoints_) {\n        if (this.freehand_) {\n          coordinates.pop();\n        } else {\n          done = true;\n        }\n      }\n      coordinates.push(coordinate.slice());\n      if (done) {\n        this.finishCoordinate_ = coordinates[0];\n      }\n      this.geometryFunction_(this.sketchCoords_, geometry);\n    }\n    this.updateSketchFeatures_();\n    if (done) {\n      this.finishDrawing();\n    }\n  };\n\n  /**\n   * Remove last point of the feature currently being drawn.\n   * @api\n   */\n  Draw.prototype.removeLastPoint = function removeLastPoint () {\n    if (!this.sketchFeature_) {\n      return;\n    }\n    var geometry = /** @type {import(\"../geom/SimpleGeometry.js\").default} */ (this.sketchFeature_.getGeometry());\n    var coordinates;\n    /** @type {LineString} */\n    var sketchLineGeom;\n    if (this.mode_ === Mode.LINE_STRING) {\n      coordinates = /** @type {LineCoordType} */ (this.sketchCoords_);\n      coordinates.splice(-2, 1);\n      this.geometryFunction_(coordinates, geometry);\n      if (coordinates.length >= 2) {\n        this.finishCoordinate_ = coordinates[coordinates.length - 2].slice();\n      }\n    } else if (this.mode_ === Mode.POLYGON) {\n      coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];\n      coordinates.splice(-2, 1);\n      sketchLineGeom = /** @type {LineString} */ (this.sketchLine_.getGeometry());\n      sketchLineGeom.setCoordinates(coordinates);\n      this.geometryFunction_(this.sketchCoords_, geometry);\n    }\n\n    if (coordinates.length === 0) {\n      this.finishCoordinate_ = null;\n    }\n\n    this.updateSketchFeatures_();\n  };\n\n  /**\n   * Stop drawing and add the sketch feature to the target layer.\n   * The {@link module:ol/interaction/Draw~DrawEventType.DRAWEND} event is\n   * dispatched before inserting the feature.\n   * @api\n   */\n  Draw.prototype.finishDrawing = function finishDrawing () {\n    var sketchFeature = this.abortDrawing_();\n    if (!sketchFeature) {\n      return;\n    }\n    var coordinates = this.sketchCoords_;\n    var geometry = /** @type {import(\"../geom/SimpleGeometry.js\").default} */ (sketchFeature.getGeometry());\n    if (this.mode_ === Mode.LINE_STRING) {\n      // remove the redundant last point\n      coordinates.pop();\n      this.geometryFunction_(coordinates, geometry);\n    } else if (this.mode_ === Mode.POLYGON) {\n      // remove the redundant last point in ring\n      /** @type {PolyCoordType} */ (coordinates)[0].pop();\n      this.geometryFunction_(coordinates, geometry);\n      coordinates = geometry.getCoordinates();\n    }\n\n    // cast multi-part geometries\n    if (this.type_ === GeometryType.MULTI_POINT) {\n      sketchFeature.setGeometry(new MultiPoint([/** @type {PointCoordType} */(coordinates)]));\n    } else if (this.type_ === GeometryType.MULTI_LINE_STRING) {\n      sketchFeature.setGeometry(new MultiLineString([/** @type {LineCoordType} */(coordinates)]));\n    } else if (this.type_ === GeometryType.MULTI_POLYGON) {\n      sketchFeature.setGeometry(new MultiPolygon([/** @type {PolyCoordType} */(coordinates)]));\n    }\n\n    // First dispatch event to allow full set up of feature\n    this.dispatchEvent(new DrawEvent(DrawEventType.DRAWEND, sketchFeature));\n\n    // Then insert feature\n    if (this.features_) {\n      this.features_.push(sketchFeature);\n    }\n    if (this.source_) {\n      this.source_.addFeature(sketchFeature);\n    }\n  };\n\n  /**\n   * Stop drawing without adding the sketch feature to the target layer.\n   * @return {Feature} The sketch feature (or null if none).\n   * @private\n   */\n  Draw.prototype.abortDrawing_ = function abortDrawing_ () {\n    this.finishCoordinate_ = null;\n    var sketchFeature = this.sketchFeature_;\n    if (sketchFeature) {\n      this.sketchFeature_ = null;\n      this.sketchPoint_ = null;\n      this.sketchLine_ = null;\n      /** @type {VectorSource} */ (this.overlay_.getSource()).clear(true);\n    }\n    return sketchFeature;\n  };\n\n  /**\n   * Extend an existing geometry by adding additional points. This only works\n   * on features with `LineString` geometries, where the interaction will\n   * extend lines by adding points to the end of the coordinates array.\n   * @param {!Feature} feature Feature to be extended.\n   * @api\n   */\n  Draw.prototype.extend = function extend (feature) {\n    var geometry = feature.getGeometry();\n    var lineString = /** @type {LineString} */ (geometry);\n    this.sketchFeature_ = feature;\n    this.sketchCoords_ = lineString.getCoordinates();\n    var last = this.sketchCoords_[this.sketchCoords_.length - 1];\n    this.finishCoordinate_ = last.slice();\n    this.sketchCoords_.push(last.slice());\n    this.updateSketchFeatures_();\n    this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));\n  };\n\n  /**\n   * Redraw the sketch features.\n   * @private\n   */\n  Draw.prototype.updateSketchFeatures_ = function updateSketchFeatures_ () {\n    var sketchFeatures = [];\n    if (this.sketchFeature_) {\n      sketchFeatures.push(this.sketchFeature_);\n    }\n    if (this.sketchLine_) {\n      sketchFeatures.push(this.sketchLine_);\n    }\n    if (this.sketchPoint_) {\n      sketchFeatures.push(this.sketchPoint_);\n    }\n    var overlaySource = /** @type {VectorSource} */ (this.overlay_.getSource());\n    overlaySource.clear(true);\n    overlaySource.addFeatures(sketchFeatures);\n  };\n\n  /**\n   * @private\n   */\n  Draw.prototype.updateState_ = function updateState_ () {\n    var map = this.getMap();\n    var active = this.getActive();\n    if (!map || !active) {\n      this.abortDrawing_();\n    }\n    this.overlay_.setMap(active ? map : null);\n  };\n\n  return Draw;\n}(PointerInteraction));\n\n\n/**\n * @return {import(\"../style/Style.js\").StyleFunction} Styles.\n */\nfunction getDefaultStyleFunction() {\n  var styles = createEditingStyle();\n  return function(feature, resolution) {\n    return styles[feature.getGeometry().getType()];\n  };\n}\n\n\n/**\n * Create a `geometryFunction` for `type: 'Circle'` that will create a regular\n * polygon with a user specified number of sides and start angle instead of an\n * `import(\"../geom/Circle.js\").Circle` geometry.\n * @param {number=} opt_sides Number of sides of the regular polygon. Default is\n *     32.\n * @param {number=} opt_angle Angle of the first point in radians. 0 means East.\n *     Default is the angle defined by the heading from the center of the\n *     regular polygon to the current pointer position.\n * @return {GeometryFunction} Function that draws a\n *     polygon.\n * @api\n */\nexport function createRegularPolygon(opt_sides, opt_angle) {\n  return function(coordinates, opt_geometry) {\n    var center = /** @type {LineCoordType} */ (coordinates)[0];\n    var end = /** @type {LineCoordType} */ (coordinates)[1];\n    var radius = Math.sqrt(\n      squaredCoordinateDistance(center, end));\n    var geometry = opt_geometry ? /** @type {Polygon} */ (opt_geometry) :\n      fromCircle(new Circle(center), opt_sides);\n    var angle = opt_angle;\n    if (!opt_angle) {\n      var x = end[0] - center[0];\n      var y = end[1] - center[1];\n      angle = Math.atan(y / x) - (x < 0 ? Math.PI : 0);\n    }\n    makeRegular(geometry, center, radius, angle);\n    return geometry;\n  };\n}\n\n\n/**\n * Create a `geometryFunction` that will create a box-shaped polygon (aligned\n * with the coordinate system axes).  Use this with the draw interaction and\n * `type: 'Circle'` to return a box instead of a circle geometry.\n * @return {GeometryFunction} Function that draws a box-shaped polygon.\n * @api\n */\nexport function createBox() {\n  return (\n    function(coordinates, opt_geometry) {\n      var extent = boundingExtent(/** @type {LineCoordType} */ (coordinates));\n      var boxCoordinates = [[\n        getBottomLeft(extent),\n        getBottomRight(extent),\n        getTopRight(extent),\n        getTopLeft(extent),\n        getBottomLeft(extent)\n      ]];\n      var geometry = opt_geometry;\n      if (geometry) {\n        geometry.setCoordinates(boxCoordinates);\n      } else {\n        geometry = new Polygon(boxCoordinates);\n      }\n      return geometry;\n    }\n  );\n}\n\n\n/**\n * Get the drawing mode.  The mode for mult-part geometries is the same as for\n * their single-part cousins.\n * @param {GeometryType} type Geometry type.\n * @return {Mode} Drawing mode.\n */\nfunction getMode(type) {\n  var mode;\n  if (type === GeometryType.POINT ||\n      type === GeometryType.MULTI_POINT) {\n    mode = Mode.POINT;\n  } else if (type === GeometryType.LINE_STRING ||\n      type === GeometryType.MULTI_LINE_STRING) {\n    mode = Mode.LINE_STRING;\n  } else if (type === GeometryType.POLYGON ||\n      type === GeometryType.MULTI_POLYGON) {\n    mode = Mode.POLYGON;\n  } else if (type === GeometryType.CIRCLE) {\n    mode = Mode.CIRCLE;\n  }\n  return (\n    /** @type {!Mode} */ (mode)\n  );\n}\n\n\nexport default Draw;\n\n//# sourceMappingURL=Draw.js.map","/**\n * @module ol/geom/flat/interpolate\n */\nimport {binarySearch} from '../../array.js';\nimport {lerp} from '../../math.js';\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} fraction Fraction.\n * @param {Array<number>=} opt_dest Destination.\n * @return {Array<number>} Destination.\n */\nexport function interpolatePoint(flatCoordinates, offset, end, stride, fraction, opt_dest) {\n  var pointX = NaN;\n  var pointY = NaN;\n  var n = (end - offset) / stride;\n  if (n === 1) {\n    pointX = flatCoordinates[offset];\n    pointY = flatCoordinates[offset + 1];\n  } else if (n == 2) {\n    pointX = (1 - fraction) * flatCoordinates[offset] +\n        fraction * flatCoordinates[offset + stride];\n    pointY = (1 - fraction) * flatCoordinates[offset + 1] +\n        fraction * flatCoordinates[offset + stride + 1];\n  } else if (n !== 0) {\n    var x1 = flatCoordinates[offset];\n    var y1 = flatCoordinates[offset + 1];\n    var length = 0;\n    var cumulativeLengths = [0];\n    for (var i = offset + stride; i < end; i += stride) {\n      var x2 = flatCoordinates[i];\n      var y2 = flatCoordinates[i + 1];\n      length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n      cumulativeLengths.push(length);\n      x1 = x2;\n      y1 = y2;\n    }\n    var target = fraction * length;\n    var index = binarySearch(cumulativeLengths, target);\n    if (index < 0) {\n      var t = (target - cumulativeLengths[-index - 2]) /\n          (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);\n      var o = offset + (-index - 2) * stride;\n      pointX = lerp(\n        flatCoordinates[o], flatCoordinates[o + stride], t);\n      pointY = lerp(\n        flatCoordinates[o + 1], flatCoordinates[o + stride + 1], t);\n    } else {\n      pointX = flatCoordinates[offset + index * stride];\n      pointY = flatCoordinates[offset + index * stride + 1];\n    }\n  }\n  if (opt_dest) {\n    opt_dest[0] = pointX;\n    opt_dest[1] = pointY;\n    return opt_dest;\n  } else {\n    return [pointX, pointY];\n  }\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} m M.\n * @param {boolean} extrapolate Extrapolate.\n * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\n */\nexport function lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, extrapolate) {\n  if (end == offset) {\n    return null;\n  }\n  var coordinate;\n  if (m < flatCoordinates[offset + stride - 1]) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(offset, offset + stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  } else if (flatCoordinates[end - 1] < m) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(end - stride, end);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  }\n  // FIXME use O(1) search\n  if (m == flatCoordinates[offset + stride - 1]) {\n    return flatCoordinates.slice(offset, offset + stride);\n  }\n  var lo = offset / stride;\n  var hi = end / stride;\n  while (lo < hi) {\n    var mid = (lo + hi) >> 1;\n    if (m < flatCoordinates[(mid + 1) * stride - 1]) {\n      hi = mid;\n    } else {\n      lo = mid + 1;\n    }\n  }\n  var m0 = flatCoordinates[lo * stride - 1];\n  if (m == m0) {\n    return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);\n  }\n  var m1 = flatCoordinates[(lo + 1) * stride - 1];\n  var t = (m - m0) / (m1 - m0);\n  coordinate = [];\n  for (var i = 0; i < stride - 1; ++i) {\n    coordinate.push(lerp(flatCoordinates[(lo - 1) * stride + i],\n      flatCoordinates[lo * stride + i], t));\n  }\n  coordinate.push(m);\n  return coordinate;\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} m M.\n * @param {boolean} extrapolate Extrapolate.\n * @param {boolean} interpolate Interpolate.\n * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\n */\nexport function lineStringsCoordinateAtM(\n  flatCoordinates, offset, ends, stride, m, extrapolate, interpolate) {\n  if (interpolate) {\n    return lineStringCoordinateAtM(\n      flatCoordinates, offset, ends[ends.length - 1], stride, m, extrapolate);\n  }\n  var coordinate;\n  if (m < flatCoordinates[stride - 1]) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(0, stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  }\n  if (flatCoordinates[flatCoordinates.length - 1] < m) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(flatCoordinates.length - stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  }\n  for (var i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    if (offset == end) {\n      continue;\n    }\n    if (m < flatCoordinates[offset + stride - 1]) {\n      return null;\n    } else if (m <= flatCoordinates[end - 1]) {\n      return lineStringCoordinateAtM(\n        flatCoordinates, offset, end, stride, m, false);\n    }\n    offset = end;\n  }\n  return null;\n}\n\n//# sourceMappingURL=interpolate.js.map","/**\n * @module ol/geom/LineString\n */\nimport {extend} from '../array.js';\nimport {closestSquaredDistanceXY} from '../extent.js';\nimport GeometryLayout from './GeometryLayout.js';\nimport GeometryType from './GeometryType.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {assignClosestPoint, maxSquaredDelta} from './flat/closest.js';\nimport {deflateCoordinates} from './flat/deflate.js';\nimport {inflateCoordinates} from './flat/inflate.js';\nimport {interpolatePoint, lineStringCoordinateAtM} from './flat/interpolate.js';\nimport {intersectsLineString} from './flat/intersectsextent.js';\nimport {lineStringLength} from './flat/length.js';\nimport {forEach as forEachSegment} from './flat/segments.js';\nimport {douglasPeucker} from './flat/simplify.js';\n\n/**\n * @classdesc\n * Linestring geometry.\n *\n * @api\n */\nvar LineString = /*@__PURE__*/(function (SimpleGeometry) {\n  function LineString(coordinates, opt_layout) {\n\n    SimpleGeometry.call(this);\n\n    /**\n     * @private\n     * @type {import(\"../coordinate.js\").Coordinate}\n     */\n    this.flatMidpoint_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.flatMidpointRevision_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDeltaRevision_ = -1;\n\n    if (opt_layout !== undefined && !Array.isArray(coordinates[0])) {\n      this.setFlatCoordinates(opt_layout, /** @type {Array<number>} */ (coordinates));\n    } else {\n      this.setCoordinates(/** @type {Array<import(\"../coordinate.js\").Coordinate>} */ (coordinates), opt_layout);\n    }\n\n  }\n\n  if ( SimpleGeometry ) LineString.__proto__ = SimpleGeometry;\n  LineString.prototype = Object.create( SimpleGeometry && SimpleGeometry.prototype );\n  LineString.prototype.constructor = LineString;\n\n  /**\n   * Append the passed coordinate to the coordinates of the linestring.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @api\n   */\n  LineString.prototype.appendCoordinate = function appendCoordinate (coordinate) {\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = coordinate.slice();\n    } else {\n      extend(this.flatCoordinates, coordinate);\n    }\n    this.changed();\n  };\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!LineString} Clone.\n   * @override\n   * @api\n   */\n  LineString.prototype.clone = function clone () {\n    return new LineString(this.flatCoordinates.slice(), this.layout);\n  };\n\n  /**\n   * @inheritDoc\n   */\n  LineString.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(maxSquaredDelta(\n        this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestPoint(\n      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,\n      this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);\n  };\n\n  /**\n   * Iterate over each segment, calling the provided callback.\n   * If the callback returns a truthy value the function returns that\n   * value immediately. Otherwise the function returns `false`.\n   *\n   * @param {function(this: S, import(\"../coordinate.js\").Coordinate, import(\"../coordinate.js\").Coordinate): T} callback Function\n   *     called for each segment.\n   * @return {T|boolean} Value.\n   * @template T,S\n   * @api\n   */\n  LineString.prototype.forEachSegment = function forEachSegment$1 (callback) {\n    return forEachSegment(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, callback);\n  };\n\n  /**\n   * Returns the coordinate at `m` using linear interpolation, or `null` if no\n   * such coordinate exists.\n   *\n   * `opt_extrapolate` controls extrapolation beyond the range of Ms in the\n   * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first\n   * M will return the first coordinate and Ms greater than the last M will\n   * return the last coordinate.\n   *\n   * @param {number} m M.\n   * @param {boolean=} opt_extrapolate Extrapolate. Default is `false`.\n   * @return {import(\"../coordinate.js\").Coordinate} Coordinate.\n   * @api\n   */\n  LineString.prototype.getCoordinateAtM = function getCoordinateAtM (m, opt_extrapolate) {\n    if (this.layout != GeometryLayout.XYM &&\n        this.layout != GeometryLayout.XYZM) {\n      return null;\n    }\n    var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;\n    return lineStringCoordinateAtM(this.flatCoordinates, 0,\n      this.flatCoordinates.length, this.stride, m, extrapolate);\n  };\n\n  /**\n   * Return the coordinates of the linestring.\n   * @return {Array<import(\"../coordinate.js\").Coordinate>} Coordinates.\n   * @override\n   * @api\n   */\n  LineString.prototype.getCoordinates = function getCoordinates () {\n    return inflateCoordinates(\n      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n  };\n\n  /**\n   * Return the coordinate at the provided fraction along the linestring.\n   * The `fraction` is a number between 0 and 1, where 0 is the start of the\n   * linestring and 1 is the end.\n   * @param {number} fraction Fraction.\n   * @param {import(\"../coordinate.js\").Coordinate=} opt_dest Optional coordinate whose values will\n   *     be modified. If not provided, a new coordinate will be returned.\n   * @return {import(\"../coordinate.js\").Coordinate} Coordinate of the interpolated point.\n   * @api\n   */\n  LineString.prototype.getCoordinateAt = function getCoordinateAt (fraction, opt_dest) {\n    return interpolatePoint(\n      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,\n      fraction, opt_dest);\n  };\n\n  /**\n   * Return the length of the linestring on projected plane.\n   * @return {number} Length (on projected plane).\n   * @api\n   */\n  LineString.prototype.getLength = function getLength () {\n    return lineStringLength(\n      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n  };\n\n  /**\n   * @return {Array<number>} Flat midpoint.\n   */\n  LineString.prototype.getFlatMidpoint = function getFlatMidpoint () {\n    if (this.flatMidpointRevision_ != this.getRevision()) {\n      this.flatMidpoint_ = this.getCoordinateAt(0.5, this.flatMidpoint_);\n      this.flatMidpointRevision_ = this.getRevision();\n    }\n    return this.flatMidpoint_;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  LineString.prototype.getSimplifiedGeometryInternal = function getSimplifiedGeometryInternal (squaredTolerance) {\n    var simplifiedFlatCoordinates = [];\n    simplifiedFlatCoordinates.length = douglasPeucker(\n      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,\n      squaredTolerance, simplifiedFlatCoordinates, 0);\n    return new LineString(simplifiedFlatCoordinates, GeometryLayout.XY);\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  LineString.prototype.getType = function getType () {\n    return GeometryType.LINE_STRING;\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  LineString.prototype.intersectsExtent = function intersectsExtent (extent) {\n    return intersectsLineString(\n      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,\n      extent);\n  };\n\n  /**\n   * Set the coordinates of the linestring.\n   * @param {!Array<import(\"../coordinate.js\").Coordinate>} coordinates Coordinates.\n   * @param {GeometryLayout=} opt_layout Layout.\n   * @override\n   * @api\n   */\n  LineString.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {\n    this.setLayout(opt_layout, coordinates, 1);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    this.flatCoordinates.length = deflateCoordinates(\n      this.flatCoordinates, 0, coordinates, this.stride);\n    this.changed();\n  };\n\n  return LineString;\n}(SimpleGeometry));\n\n\nexport default LineString;\n\n//# sourceMappingURL=LineString.js.map","/**\n * @module ol/geom/MultiLineString\n */\nimport {extend} from '../array.js';\nimport {closestSquaredDistanceXY} from '../extent.js';\nimport GeometryLayout from './GeometryLayout.js';\nimport GeometryType from './GeometryType.js';\nimport LineString from './LineString.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {assignClosestArrayPoint, arrayMaxSquaredDelta} from './flat/closest.js';\nimport {deflateCoordinatesArray} from './flat/deflate.js';\nimport {inflateCoordinatesArray} from './flat/inflate.js';\nimport {interpolatePoint, lineStringsCoordinateAtM} from './flat/interpolate.js';\nimport {intersectsLineStringArray} from './flat/intersectsextent.js';\nimport {douglasPeuckerArray} from './flat/simplify.js';\n\n/**\n * @classdesc\n * Multi-linestring geometry.\n *\n * @api\n */\nvar MultiLineString = /*@__PURE__*/(function (SimpleGeometry) {\n  function MultiLineString(coordinates, opt_layout, opt_ends) {\n\n    SimpleGeometry.call(this);\n\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n    this.ends_ = [];\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDeltaRevision_ = -1;\n\n    if (Array.isArray(coordinates[0])) {\n      this.setCoordinates(/** @type {Array<Array<import(\"../coordinate.js\").Coordinate>>} */ (coordinates), opt_layout);\n    } else if (opt_layout !== undefined && opt_ends) {\n      this.setFlatCoordinates(opt_layout, /** @type {Array<number>} */ (coordinates));\n      this.ends_ = opt_ends;\n    } else {\n      var layout = this.getLayout();\n      var lineStrings = /** @type {Array<LineString>} */ (coordinates);\n      var flatCoordinates = [];\n      var ends = [];\n      for (var i = 0, ii = lineStrings.length; i < ii; ++i) {\n        var lineString = lineStrings[i];\n        if (i === 0) {\n          layout = lineString.getLayout();\n        }\n        extend(flatCoordinates, lineString.getFlatCoordinates());\n        ends.push(flatCoordinates.length);\n      }\n      this.setFlatCoordinates(layout, flatCoordinates);\n      this.ends_ = ends;\n    }\n\n  }\n\n  if ( SimpleGeometry ) MultiLineString.__proto__ = SimpleGeometry;\n  MultiLineString.prototype = Object.create( SimpleGeometry && SimpleGeometry.prototype );\n  MultiLineString.prototype.constructor = MultiLineString;\n\n  /**\n   * Append the passed linestring to the multilinestring.\n   * @param {LineString} lineString LineString.\n   * @api\n   */\n  MultiLineString.prototype.appendLineString = function appendLineString (lineString) {\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = lineString.getFlatCoordinates().slice();\n    } else {\n      extend(this.flatCoordinates, lineString.getFlatCoordinates().slice());\n    }\n    this.ends_.push(this.flatCoordinates.length);\n    this.changed();\n  };\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!MultiLineString} Clone.\n   * @override\n   * @api\n   */\n  MultiLineString.prototype.clone = function clone () {\n    return new MultiLineString(this.flatCoordinates.slice(), this.layout, this.ends_.slice());\n  };\n\n  /**\n   * @inheritDoc\n   */\n  MultiLineString.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(arrayMaxSquaredDelta(\n        this.flatCoordinates, 0, this.ends_, this.stride, 0));\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestArrayPoint(\n      this.flatCoordinates, 0, this.ends_, this.stride,\n      this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);\n  };\n\n  /**\n   * Returns the coordinate at `m` using linear interpolation, or `null` if no\n   * such coordinate exists.\n   *\n   * `opt_extrapolate` controls extrapolation beyond the range of Ms in the\n   * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first\n   * M will return the first coordinate and Ms greater than the last M will\n   * return the last coordinate.\n   *\n   * `opt_interpolate` controls interpolation between consecutive LineStrings\n   * within the MultiLineString. If `opt_interpolate` is `true` the coordinates\n   * will be linearly interpolated between the last coordinate of one LineString\n   * and the first coordinate of the next LineString.  If `opt_interpolate` is\n   * `false` then the function will return `null` for Ms falling between\n   * LineStrings.\n   *\n   * @param {number} m M.\n   * @param {boolean=} opt_extrapolate Extrapolate. Default is `false`.\n   * @param {boolean=} opt_interpolate Interpolate. Default is `false`.\n   * @return {import(\"../coordinate.js\").Coordinate} Coordinate.\n   * @api\n   */\n  MultiLineString.prototype.getCoordinateAtM = function getCoordinateAtM (m, opt_extrapolate, opt_interpolate) {\n    if ((this.layout != GeometryLayout.XYM &&\n         this.layout != GeometryLayout.XYZM) ||\n        this.flatCoordinates.length === 0) {\n      return null;\n    }\n    var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;\n    var interpolate = opt_interpolate !== undefined ? opt_interpolate : false;\n    return lineStringsCoordinateAtM(this.flatCoordinates, 0,\n      this.ends_, this.stride, m, extrapolate, interpolate);\n  };\n\n  /**\n   * Return the coordinates of the multilinestring.\n   * @return {Array<Array<import(\"../coordinate.js\").Coordinate>>} Coordinates.\n   * @override\n   * @api\n   */\n  MultiLineString.prototype.getCoordinates = function getCoordinates () {\n    return inflateCoordinatesArray(\n      this.flatCoordinates, 0, this.ends_, this.stride);\n  };\n\n  /**\n   * @return {Array<number>} Ends.\n   */\n  MultiLineString.prototype.getEnds = function getEnds () {\n    return this.ends_;\n  };\n\n  /**\n   * Return the linestring at the specified index.\n   * @param {number} index Index.\n   * @return {LineString} LineString.\n   * @api\n   */\n  MultiLineString.prototype.getLineString = function getLineString (index) {\n    if (index < 0 || this.ends_.length <= index) {\n      return null;\n    }\n    return new LineString(this.flatCoordinates.slice(\n      index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);\n  };\n\n  /**\n   * Return the linestrings of this multilinestring.\n   * @return {Array<LineString>} LineStrings.\n   * @api\n   */\n  MultiLineString.prototype.getLineStrings = function getLineStrings () {\n    var flatCoordinates = this.flatCoordinates;\n    var ends = this.ends_;\n    var layout = this.layout;\n    /** @type {Array<LineString>} */\n    var lineStrings = [];\n    var offset = 0;\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n      var end = ends[i];\n      var lineString = new LineString(flatCoordinates.slice(offset, end), layout);\n      lineStrings.push(lineString);\n      offset = end;\n    }\n    return lineStrings;\n  };\n\n  /**\n   * @return {Array<number>} Flat midpoints.\n   */\n  MultiLineString.prototype.getFlatMidpoints = function getFlatMidpoints () {\n    var midpoints = [];\n    var flatCoordinates = this.flatCoordinates;\n    var offset = 0;\n    var ends = this.ends_;\n    var stride = this.stride;\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n      var end = ends[i];\n      var midpoint = interpolatePoint(\n        flatCoordinates, offset, end, stride, 0.5);\n      extend(midpoints, midpoint);\n      offset = end;\n    }\n    return midpoints;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  MultiLineString.prototype.getSimplifiedGeometryInternal = function getSimplifiedGeometryInternal (squaredTolerance) {\n    var simplifiedFlatCoordinates = [];\n    var simplifiedEnds = [];\n    simplifiedFlatCoordinates.length = douglasPeuckerArray(\n      this.flatCoordinates, 0, this.ends_, this.stride, squaredTolerance,\n      simplifiedFlatCoordinates, 0, simplifiedEnds);\n    return new MultiLineString(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEnds);\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  MultiLineString.prototype.getType = function getType () {\n    return GeometryType.MULTI_LINE_STRING;\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  MultiLineString.prototype.intersectsExtent = function intersectsExtent (extent) {\n    return intersectsLineStringArray(\n      this.flatCoordinates, 0, this.ends_, this.stride, extent);\n  };\n\n  /**\n   * Set the coordinates of the multilinestring.\n   * @param {!Array<Array<import(\"../coordinate.js\").Coordinate>>} coordinates Coordinates.\n   * @param {GeometryLayout=} opt_layout Layout.\n   * @override\n   * @api\n   */\n  MultiLineString.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {\n    this.setLayout(opt_layout, coordinates, 2);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    var ends = deflateCoordinatesArray(\n      this.flatCoordinates, 0, coordinates, this.stride, this.ends_);\n    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];\n    this.changed();\n  };\n\n  return MultiLineString;\n}(SimpleGeometry));\n\n\nexport default MultiLineString;\n\n//# sourceMappingURL=MultiLineString.js.map"],"sourceRoot":""}